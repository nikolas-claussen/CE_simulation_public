CE_simulation
================

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Install

#### Dependencies

- Developed using `python 3.9`
- The basics: `numpy, matplotlib, scipy` - should be contained in your
  anaconda install
- `jupyter`: if you are reading this, you probably already have that
  installed.
- `JAX` version `0.3.25`, used to automatically differentiate energy
  functions for optimization
- `nbdev, fastcore, nptyping`. These libraries are used for development
  purposes:
  - `nbdev` is the jupyter-notebook development environment used to
    generate modules from jupyter notebooks, see https://nbdev.fast.ai/.
  - `fastcore` offers helpful add-ons for notebook-based development,
    e.g. `@patch`. See https://fastcore.fast.ai/
  - `nptyping` allows to add type hints to array variables
    (e.g. `trace(x: NDArray[Shape["2,2"], Float]) -> float`
- `ipywidgets, tqdm` for interactive plots and progress bars in jupyter
  notebooks

#### Installing the modules

To install the modules, run

``` sh
pip install CE_simulation
```

or, from within the module directory,

``` sh
pip install -e '.[dev]'
```

in case you want to continue modifying the code.

## Overview

The code is organized as follows:

- `00_triangle_data_structure` defines the data structure used to model
  2d epithelial sheets, the
  [`HalfEdgeMesh`](https://nikolas-claussen.github.io/CE_simulation/triangle_data_structure.html#halfedgemesh).
  It takes care of book-keeping (which cell has what coordinates? which
  cell-cell junction connects which edges) and provides routines for
  analysis of tissue geometry.

- `01_tension_time_evolution` uses the
  [`HalfEdgeMesh`](https://nikolas-claussen.github.io/CE_simulation/triangle_data_structure.html#halfedgemesh)
  to model the time evolution of the tension triangulation. This is done
  in two steps:

  - Autonomous dynamics of junction intrinsic active & passive tensions
  - A “flattening” step, which ensures the tension triangulation remains
    flat.

- `02_delaunay_simulation` shows an example simulation work flow, using
  the Voronoi construction to compute the primal cell vertices from the
  triangulation

- `03_real_shape_optimization` defines routines for computing the primal
  cell vertex positions by constrained minimization cell-shape
  elasticity

- `04_drosophila_simulation` contains a complete simulation of an
  idealized *Drosophila* germ band. `04a` is a copy of `04`, to be used
  as playground.

  - There is also a sample script to run a simulation from a terminal
    based on notebook `04`, `run_simulation.py`.

- `05_periodic_bcs`, TO BE DONE - periodic boundary conditions

- `06_isogonal_hessian` studies the projection of cell elastic energy
  onto the space of isogonal modes and contains tools to compute & apply
  isogonal transformations.

The code is written in object-oriented style - the central class being
the
[`HalfEdgeMesh`](https://nikolas-claussen.github.io/CE_simulation/triangle_data_structure.html#halfedgemesh)
and its subclasses, which should make writing new simulations and/or
analysis code relatively straightforward.

However, the code has two major “cruxes”, which you need to understand
if you want to carry out major modifications: - The
[`HalfEdgeMesh`](https://nikolas-claussen.github.io/CE_simulation/triangle_data_structure.html#halfedgemesh)
data structure and its implementation. The implementation is somewhat
subtle because python does have proper pointers. - The energy
optimization routines. To use automatic differentiation and efficient
numerical optimizers, we need to “serialize” a mesh into a set of
arrays, which can be a bit finicky.

To get started, it’s probably best to work through the notebooks in
order.
