# AUTOGENERATED! DO NOT EDIT! File to edit: ../13_ltc_distribution_analysis.ipynb.

# %% auto 0
__all__ = ['weighted_quantiles', 'reduce_identical_blocks', 'has_rev', 'get_irrev_T1s', 'get_T1_rate_from_dict']

# %% ../13_ltc_distribution_analysis.ipynb 3
import jax
import jax.numpy as jnp
from jax import grad as jgrad
from jax import jit
from jax.config import config

jax.default_device(jax.devices('cpu')[0])
config.update("jax_enable_x64", True)
config.update("jax_debug_nans", False)
config.update("jax_platform_name", "cpu")

# %% ../13_ltc_distribution_analysis.ipynb 4
import CE_simulation.mesh as msh
import CE_simulation.tension as tns
import CE_simulation.delaunay as dln
import CE_simulation.isogonal as iso
import CE_simulation.drosophila as drs
import CE_simulation.disorder as dis
import CE_simulation.hessian as hes
import CE_simulation.ecmc as ecm
import CE_simulation.phase_analysis as ana

# %% ../13_ltc_distribution_analysis.ipynb 5
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.collections import LineCollection
from mpl_toolkits.mplot3d.art3d import Line3DCollection

from tqdm.notebook import tqdm

from scipy import spatial, ndimage
from skimage.transform import downscale_local_mean

from collections import Counter
import itertools

from copy import deepcopy
import os
import pickle

# %% ../13_ltc_distribution_analysis.ipynb 6
from joblib import Parallel, delayed
import gc

# %% ../13_ltc_distribution_analysis.ipynb 7
from typing import Sequence, Union, Dict, List, Tuple, Iterable, Callable, Any
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../13_ltc_distribution_analysis.ipynb 33
def weighted_quantiles(values, weights, quantiles=0.5):
    """Source: https://stackoverflow.com/questions/20601872/numpy-or-scipy-to-calculate-weighted-median"""
    i = np.argsort(values)
    c = np.cumsum(weights[i])
    return values[i[np.searchsorted(c, np.array(quantiles) * c[-1])]]

# %% ../13_ltc_distribution_analysis.ipynb 86
def reduce_identical_blocks(lst):
    """Reduce blocks of identical elements in lst to single entry, i.e. [a,a,a,b,b] -> [a, b]"""
    reduced = [lst[0]]
    for x in lst:
        if x != reduced[-1]:
            reduced.append(x)
    return reduced

def has_rev(lst, dist=2):
    """Does the list have a reversible change with given distance, e.g. [a,b,a,c,d], with dist=2"""
    return [lst[i]==lst[i+2] for i in range(len(lst)-2)]

def get_irrev_T1s(meshes, dist=2):
    """Returns a dict {he: [timepoints,]}. Assumes meshes always has same edges. T1s are dated to the definitive emergence of the new interface"""
    T1_dict = {}
    keys = [he._heid for he in meshes[0].hes.values() if not he.duplicate]
    for he_id in tqdm(keys):
        vertices = []
        uniques = []
        for m in meshes:
            vs = tuple(sorted([v._vid for v in m.hes[he_id].vertices]))
            vertices.append(vs)
            if not vs in uniques:
                uniques.append(vs)
        which_one = np.array([[ix for ix, x in enumerate(uniques) if vs == x][0] for vs in vertices])
        reduced = reduce_identical_blocks(which_one)
        irrev = deepcopy(reduced)
        while any(has_rev(irrev, dist=dist)):
            where = np.where(has_rev(irrev, dist=dist))[0][0]
            del irrev[where:where+dist]
        T1_times = [np.argmax(which_one==x) for x in irrev[1:]]
        T1_dict[he_id] = T1_times
    return T1_dict

def get_T1_rate_from_dict(T1_dict, t_max=None):
    """Get the number of t1s/timepoint from a T1_dict {he: [timepoints,]}"""
    if t_max is None:
        t_max = max([max(x) for x in T1_dict.values() if x])
    irrev_T1_rate_proper = np.zeros(t_max)
    for val in T1_dict.values():
        for i in val:
            irrev_T1_rate_proper[i] += 1
    return irrev_T1_rate_proper.astype(int)
