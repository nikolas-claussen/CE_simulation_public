# AUTOGENERATED! DO NOT EDIT! File to edit: ../03_real_shape_optimization.ipynb.

# %% auto 0
__all__ = ['get_E_jac', 'get_shape_tensor', 'CellVertex', 'CellHalfEdgeMesh', 'get_shape_energy', 'get_vertex_energy',
           'jit_signature', 'get_default_args', 'get_args', 'kwargs_to_args', 'get_circumcenter', 'get_E',
           'rotate_about_center']

# %% ../03_real_shape_optimization.ipynb 3
import CE_simulation.mesh as msh
import CE_simulation.tension as tns
import CE_simulation.delaunay as dln

# %% ../03_real_shape_optimization.ipynb 4
import os
import sys

import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

from scipy import optimize

from tqdm.notebook import tqdm

from copy import copy, deepcopy
import pickle

# %% ../03_real_shape_optimization.ipynb 5
from dataclasses import dataclass

from typing import Union, Dict, List, Tuple, Iterable, Callable, Any
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../03_real_shape_optimization.ipynb 6
import jax
import jax.numpy as jnp
from jax import grad as jgrad
from jax import jit
from jax.tree_util import Partial

from jax.config import config
config.update("jax_enable_x64", True) # 32 bit leads the optimizer to complain about precision loss
config.update("jax_debug_nans", False) # useful for debugging, but makes code slower!

# %% ../03_real_shape_optimization.ipynb 7
import ipywidgets as widgets
from matplotlib import animation, rc

# %% ../03_real_shape_optimization.ipynb 10
def get_shape_tensor(poly: NDArray[Shape["*,2,..."],Float], epsilon_l=1e-4) -> NDArray[Shape["2,2,..."],Float]:
    """
    Compute shape tensor from polygon vertex coords.
    
    Assumes that the vertex coords are order clock- or counter-clockwise.
    Computes Sum_e l_e \outer l_e / |l_e| where l_e is the vector along
    polygon e.
    
    Parameters
    ----------
    poly : (n_vertices, 2, n_samples) array
        Input polygon(s)
    epsilon_l : float
        Regularization to keep function diff'ble for 0-edge length polygons
        
    Returns
    -------
    (2, 2, n_samples) array
        Shape tensor
    """

    edges = poly - jnp.roll(poly, 1, axis=0)
    lengths = jnp.sqrt(jnp.sum(edges**2, axis=1)+epsilon_l**2) # to make differentiable
    units = (edges.swapaxes(1,0)/lengths).swapaxes(1,0)
    return jnp.einsum('ei...,ej...->ij...', edges, units)

# %% ../03_real_shape_optimization.ipynb 12
@dataclass
class CellVertex(msh.Vertex):
    """Vertex with attributes for primal shape optimization: rest_shape, 2x2 matrix of reference shape.""" 
    rest_shape = np.array([[1.0, 0.0], [0.0, 1.0]])
    
    def __repr__(self):
        return super().__repr__().replace('Vertex', 'CellVertex')
        
    def unwrap(self, in_place=True):
        """Cast to Vertex base class."""
        v = self if in_place else copy(self)
        v.__class__ = msh.Vertex
        del v.rest_shape
        if not in_place:
            return v
    def get_shape_tensor(self) -> NDArray[Shape["2,2"],Float]:
        """Get shape tensor for a vertex (=primal cell) using get_shape_tensor. Returns Id for bdry vertices."""
        if self.is_bdry():
            return np.eye(2)
        return get_shape_tensor(self.primal_coords)

        
@patch
def wrap_as_CellVertex(self: msh.Vertex, rest_shape=np.array([[1.0, 0.0], [0.0, 1.0]]), in_place=True
                       ) -> Union[None, CellVertex]:
    """
    In-place/copy upcast from Vertex to CellVertex.
    
    Internal, for use in CellHalfEdgeMesh.__init__.
    """
    v = self if in_place else copy(self)
    v.__class__ = CellVertex
    v.rest_shape = rest_shape
    if not in_place:
        return v

# %% ../03_real_shape_optimization.ipynb 15
class CellHalfEdgeMesh(tns.TensionHalfEdgeMesh):
    """
    HalfEdgeMesh with methods for cell shape optimization & active triangulation dynamics.
    
    Can be instantiated from a HalfEdgeMesh or ListOfVerticesAndFaces. Also stores
    the boundary conditions, in the form of a list of tuples (vertex ids, penalty function).
    
    """
    def __new__(cls, mesh: Union[None, msh.HalfEdgeMesh, tns.TensionHalfEdgeMesh]= None):
        if isinstance(mesh, msh.HalfEdgeMesh):
            mesh = tns.TensionHalfEdgeMesh(mesh)
            mesh.__class__ = cls
            return mesh
        return super().__new__(cls)
    def __init__(self, mesh: Union[msh.ListOfVerticesAndFaces, msh.HalfEdgeMesh], bdry_list=None):
        super().__init__(mesh)
        for v in self.vertices.values():
            v.wrap_as_CellVertex(in_place=True)
        self.bdry_list = [] if bdry_list is None else bdry_list
            
    def save_mesh(self, fname: str, save_attribs=False) -> None:
        super().save_mesh(fname, save_rest_passive=save_attribs)
        if save_attribs:
            pickle.dump({key: val.rest_shape for key, val in self.vertices.items()},
                        open(f"{fname}_rest_shape.p", "wb"))
    save_mesh.__doc__ = (msh.HalfEdgeMesh.save_mesh.__doc__
                         +'\n Can also pickle passive, rest & rest_shape attributes as dicts at fname_{...}.p')
    
    def unwrap(self):
        """In-place cast to HalfEdgeMesh base class."""
        self.__class__ = msh.HalfEdgeMesh
        for v in self.vertices.values():
            v.unwrap(in_place=True)
        for he in self.hes.values():
            he.unwrap(in_place=True)

    @staticmethod
    def load_mesh(fname: str, load_attribs=False):
        """
        Load from file as saved by mesh.save_mesh.
        
        Can load rest/passive attributes of half edges & rest shapes of vertices,
        if saved as pickled dicts at fname_{...}.p
        """
        mesh = CellHalfEdgeMesh(super(tns.TensionHalfEdgeMesh, tns.TensionHalfEdgeMesh).load_mesh(fname))
        if load_attribs:
            rest_dict = pickle.load(open(f'{fname}_rest.p', 'rb'))
            passive_dict = pickle.load(open(f'{fname}_passive.p', 'rb'))
            rest_shape_dict = pickle.load(open(f'{fname}_rest_shape.p', 'rb'))
            for key, he in mesh.hes.items():
                he.rest = rest_dict[key]
                he.passive = passive_dict[key]
            for key, v in mesh.vertices.items():
                v.rest_shape = rest_shape_dict[key]
        return mesh

# %% ../03_real_shape_optimization.ipynb 20
@patch
def set_rest_shapes(self: CellHalfEdgeMesh) -> None:
    """Set rest shape for all mesh vertices to current shape tensor."""
    for v in self.vertices.values():
        v.rest_shape = v.get_shape_tensor()

# %% ../03_real_shape_optimization.ipynb 24
def get_shape_energy(poly: NDArray[Shape["*,2"],Float],
                     rest_shape: NDArray[Shape["2,2"],Float]=np.eye(2), A0=np.sqrt(3)/2,
                     mod_shear=.5, mod_bulk=1, mod_area=0) -> float:
    """
    Compute shape tensor energy for polygon.
    
    Includes also an optional term for area elasticity.
    
    Parameters
    ----------
    poly: (n_vertices, 2) array
        cell vertex array. assumed to be ordered correctly
    rest_shape: (2, 2) array
        reference shape
    A0: float
        reference area
    mod_shear, mod_bulk, mod_area:
        Elastic moduli.
    
    Returns
    -------
    float
        elastic energy
    
    """
    shape_tensor = get_shape_tensor(poly)
    area = tns.polygon_area(poly)
    delta = shape_tensor-rest_shape
    return mod_shear*(delta**2).sum()+mod_bulk*np.trace(delta)**2+mod_area*(area-A0)**2


def get_vertex_energy(poly: NDArray[Shape["*,2"],Float], A0=np.sqrt(3)/2, P0=1, mod_area=1, mod_perimeter=0):
    """
    Get vertex-model style energy for (ordered) polygon.
    
    E = mod_area * (area-A0)^2 + mod_perimeter * (perimeter-P0)^2
    
    """
    return mod_bulk*(tns.polygon_area(poly)-A0)**2 + mod_perimeter*(tns.polygon_perimeter(poly)-P0)**2


@patch
def get_shape_energies(self: CellHalfEdgeMesh, mod_shear=.5, mod_bulk=1, mod_area=0, A0=np.sqrt(3)/2):
    res_dict = {}
    for v in self.vertices.values():
        if v.is_bdry():
            res_dict[v._vid] = None
        else:
            res_dict[v._vid] = get_shape_energy(v.primal_coords, rest_shape=v.rest_shape, A0=A0,
                                                mod_shear=mod_shear, mod_bulk=mod_bulk, mod_area=mod_area)
    return res_dict

# %% ../03_real_shape_optimization.ipynb 27
import inspect

def jit_signature(func):
    """Version of inspect.signature which also works for JITed functions"""
    return inspect.signature(func._fun) if hasattr(func, '_fun') else inspect.signature(func)

def get_default_args(func):
    """Get dictionary of default values for function arguments"""
    signature = jit_signature(func)
    return {k: v.default for k, v in signature.parameters.items() 
            if v.default is not inspect.Parameter.empty}

def get_args(func):
    """Return positional and kwargs of a function, in definition order."""
    signature = jit_signature(func)
    pos_args = [k for k, v in signature.parameters.items() if v.default is inspect.Parameter.empty]
    kw_args = [k for k, v in signature.parameters.items() if not v.default is inspect.Parameter.empty]
    
    return pos_args, kw_args

def kwargs_to_args(func: Callable, kwargs: Dict, skip_first=1) -> List:
    """
    Format dictionary of keyword arguments into list of arguments in definition order.
    
    Optionally, you can skip the $n first arguments, which will then not be included in
    the returned list. The kwargs dict can contain more keys than the function has args,
    in which case the non-matching keys are ignored, or fewer, in which case the default
    values (if exist - else, an error is raised) will be used.
    
    The use case is interfacing between a function with many arguments (say an energy function
    which depends on some fixed connectivity or weight matrix, various parameters, etc) and
    the scipy optimizers and ODE solvers which can only pass lists of arguments. Use this function
    to convert a dict into a list with the guaranteed order and automatic filling-in of default
    values. The first $skip_first arguments of the function are not included in the list, since they
    will typically correspond to the dynamical args during optimization (1st arg) or ODE
    integration (1st and 2nd).
    """
    pos_args, kw_args = get_args(func)
    default_vals = get_default_args(func)
    
    args_list = []
    for arg in pos_args[skip_first:]:
        try:
            args_list.append(kwargs[arg])       
        except KeyError:
            raise KeyError(f'Missing positional argument {arg}')
    for arg in kw_args:
        try:
            args_list.append(kwargs[arg])       
        except KeyError:
            args_list.append(default_vals[arg])
    return tuple(args_list)  # important to return tuple otherwise scipy complains

# %% ../03_real_shape_optimization.ipynb 29
@patch
def primal_vertices_to_vector(self: CellHalfEdgeMesh, coordinate_dict=None,
                              flattened=True) -> NDArray[Shape["*"],Float]:
    """
    Format primal vertices for use in energy minimization.
    
    Returns vector of primal vertex positions (=cell vertices, associated with triangles).
    Faces are inserted into the vector ordered according to their keys.
    If flattened, flatten into 1d array in C-order. Else, return (n_faces, 2 array)
    
    If coordinate_dict is not None, this function will serialize the vertex positions saved in the 
    coordinate_dict, otherwise the vertex positions saved internally
    
    """
    face_keys = sorted(self.faces.keys())
    if coordinate_dict is None:
        primal_vertex_vector = np.stack([self.faces[key].primal_coords for key in face_keys])
    else:
        primal_vertex_vector = np.stack([coordinate_dict[key] for key in face_keys])
    if flattened:
        return primal_vertex_vector.reshape(2*primal_vertex_vector.shape[0])
    return primal_vertex_vector
       
@patch
def vector_to_primal_vertices(self: CellHalfEdgeMesh, x0: NDArray[Shape["*"],Float], flattened=True,
                              ) -> Dict[int, NDArray[Shape["2"],Float]]:
    """
    Reverse of primal_vertices_to_vector, deserialize result of energy minimization.
    
    Returns dict _fcid: primal vertex position.
    """
    face_keys = sorted(self.faces.keys())
    if flattened:
        primal_vertex_vector = x0.reshape((int(x0.shape[0]/2), 2))
    else:
        primal_vertex_vector = x0
    return {key: val for key, val in zip(face_keys, primal_vertex_vector)}


# %% ../03_real_shape_optimization.ipynb 36
@jit
def get_circumcenter(a: NDArray[Shape["2"],Float], b: NDArray[Shape["2"],Float], c: NDArray[Shape["2"], Float]
                    ) -> NDArray[Shape["2"],Float]:
    """Return circumcenter coordinates of triangle with lengths a, b, c (JIT version)"""
    b_, c_ = (b-a, c-a)
    d_ = 2*(b_[0]*c_[1]-b_[1]*c_[0])
    u_ = jnp.array([c_[1]*jnp.sum(b_**2)-b_[1]*jnp.sum(c_**2), b_[0]*jnp.sum(c_**2)-c_[0]*jnp.sum(b_**2)]) / d_
    r = jnp.linalg.norm(u_)
    return u_ + a


# %% ../03_real_shape_optimization.ipynb 37
@patch
def serialize_primal(self: CellHalfEdgeMesh, cell_attribs=('rest_shape',)):
    """
    Get arrays to compute primal energy from primal vertices in JAX-compatible way.
    
    This function serializes a HalfEdgeMesh into a bunch of arrays which are used to
    compute the shape-tensor-based cell elastic energy. Boundary conditions, implemented
    as soft constraints, are passed as a list of pairs (penalty function, vertex ids)
    where 'vertex ids' is the list of vertices on a boundary, and 'penalty function'
    is the constraint potential, via the CellHalfEdgeMesh's 'bdry_list' attribute.
        
    The function also returns an cell_list_vids array which is used internally to allow to
    make elastic moduli in the energy function cell-identity (=vertex id) dependent.
    
    Parameters
    ----------
    cell_attribs: tuple of str
        Tuple of vertex attributes to serialize. Typically, these are reference values
        for the computation of the cell shape energy, e.g. the reference shape tensor.
    
    Returns
    -------
    Dict, with the following entries
    
    e_lst_primal: (n_edges, 2) array of ints
        Indices defining primal edges (i.e. edges of the cell tesselation). 
        Edges are ordered alphanumerically by edge key.
    e_dual: (n_edges, 2) array of floats
        Normal vectors of dual edges corresponding to the primal edges in e_lst_primal.
        Their length is equal to the dual edge length (=tension).
        Used to enforce angle constraint. Edges are ordered alphanumerically by edge key.
    cell_list: (n_cells, n_valence) array of ints
        Indices defining primal edges. n_valence is the number of vertices of the highest-valence
        cell in the mesh (e.g. 6 if there are only hexagons). Cells with fewer than n_valence
        vertices are padded by repeating the last vertex, so that the elastic energy is not changed.
        Cells are ordered alphanumerically by vertex key, with possible omissions for boundary 
        vertices.
    valence_mask: (n_cells, n_valence) array of 0/1
        Mask indicating whether there is any padding in a cell. Required internally to make the
        padding hack work.
        allow elastic moduli to be a function of cell identity.
    bdry_list: list
        Slightly reformated version of input argument bdry_list.
    cell_attribs: (n_cells, ...) array
        Array of cell attributes, e.g. reference areas. For example:
        
        rest_shapes: (n_cells, 2, 2) array:
            Reference shapes of all cells as single array.
    
    and, as a separate return value not included in the dict:
    
    cell_list_vids: (n_cells) array of ints
        Array of the vertex ids corresponding to the cells in cell_list. This argument is used e.g. to
        create elastic moduli which depend on the cell identity
        
    """
    # book-keeping
    face_key_dict = {key: ix for ix, key in enumerate(sorted(self.faces.keys()))}
    bdry_list = [bdry + [[]] for bdry in self.bdry_list] #  3rd entry is for the cell ids 

    # serializing the cells, eg.g. for shape tensor energy
    cell_list = []
    circum_cen_list = []
    cell_attrib_dict = {key: [] for key in cell_attribs}
    # for future "convenience" also return a vector of _vids corresponding to the cell list
    cell_list_vids = []
    for vkey, v in sorted(self.vertices.items()):
        if not v.is_bdry():
            cell_list.append(jnp.array([face_key_dict[fc._fid] for fc in v.faces]))
            cell_list_vids.append(vkey)
            # check if the cell is in any bdry:
            for bdry in bdry_list:
                if vkey in bdry[1]:
                    bdry[2].append(len(cell_list)-1)
            # serialize the vertex attributes
            for attrib, val in cell_attrib_dict.items():
                val.append(getattr(v, attrib))
    valences = [len(cell) for cell in cell_list]
    max_valence = max(valences)
    valence_mask = jnp.array([x*[1,]+(max_valence-x)*[0,] for x in valences])
    # valence mask = (n_cells, max_valence). entry for each cell indicates whether a vertex is a duplicate
    cell_list = jnp.array([jnp.pad(cell, (0, max_valence-len(cell)), mode="edge") for cell in cell_list])
    bdry_list = [[bdry[0], jnp.array(bdry[2])] for bdry in bdry_list]
    cell_attrib_dict = {key: np.stack(val) for key, val in cell_attrib_dict.items()}
    
    # serialize edges, including dual edges for the angle penalty
    e_dual = [] # dual vertices do not move during optimization, so collect the actual edges
    l_dual = [] # length of dual edges, = tension.
    e_lst_primal = [] # for primal, collect the indices

    for _, he in sorted(self.hes.items()):
        if not he.is_bdry() and he.duplicate:
            dual_edge = he.vertices[1].coords-he.vertices[0].coords
            # rotate by 90 degrees
            dual_edge = jnp.array([dual_edge[1], -dual_edge[0]])
            primal_edge = [face_key_dict[fc._fid] for fc in [he.face, he.twin.face]] # 0= he, 1= twin
            e_dual.append(dual_edge)
            e_lst_primal.append(primal_edge)
    e_dual = jnp.array(e_dual)
    l_dual = jnp.array(l_dual)
    e_lst_primal = jnp.array(e_lst_primal)        
    
    return_dict = {'e_lst_primal': e_lst_primal, 'e_dual': e_dual,
                   'cell_list': cell_list, 'valence_mask': valence_mask,
                   'bdry_list': bdry_list} | cell_attrib_dict
    
    return return_dict, cell_list_vids

# %% ../03_real_shape_optimization.ipynb 41
@jit
def get_E(x0, e_lst_primal, e_dual, cell_list, bdry_list, valence_mask,
          mod_bulk=0, mod_shear=0, rest_shape=np.sqrt(3)*np.eye(2),
          mod_area=0, A0=np.sqrt(3)/2, mod_perimeter=0, P0=2*np.sqrt(3),
          angle_penalty=1000, bdry_penalty=1000, epsilon_l=(1e-3, 1e-3)):
    """
    Compute cell elastic energy with angle & boundary constraint penalties.
    
    For mathematical details about the energy function see paper. Implements
    shape tensor elasticity and/or vertex-model elasticity.
    
    This function relies on the arrays produced by the mesh serialization routine
    mesh.serialize_primal(). The first argument is the vector representing
    the primal vertex coordinates, as given by msh.HalfEdgeMesh.primal_vertices_to_vector
    The other required arguments are the serialization arrays. Usage example:
    
    x0 = mesh.primal_vertices_to_vector()
    serialized_dict, cell_ids = mesh.serialize_primal()
    E = get_E(x0, **energy_arrays, mod_bulk=1)
    
    Parameters, i.e. the pre-factors of the different terms in the elastic energy are
    given by the keyword arguments.
    
    Parameters
    ----------
    x0 : (2*n_cell_vertices) array
        As produced by msh.HalfEdgeMesh.primal_vertices_to_vector
    .... : arrays
        Serialization arrays, see msh.HalfEdgeMesh.get_primal_energy_fct_jax
    mod_bulk, mod_shear, reference_shape: float, float, np.array of shape (..., 2, 2)
        Moduli and reference shape for shape-tensor elasticity
    mod_area, A0, mod_perimeter, P0: float
        Moduli and reference area/perimeter for vertex-model elasticity
    angle_penalty, bdry_penalty: float
        Penalties enforcing area and boundary constraints.
        angle_penalty can be patterned (i.e. distinct for different edges), in
        which case it needs to be a (len(e_lst_primal),) shape vector.
    epsilon_l: tuple (float, float)
        Regularization for short-length edges, required for differentiability.
        The 0st entry is the regularization for the shape energy,
        and the 1st the one for the angle penalty
    
    Returns
    -------
    float
        Elastic energy + angle & boundary condition penalties
    
    """
    pts = jnp.reshape(x0, (int(x0.shape[0]/2), 2))
    cells = jnp.stack([pts[i] for i in cell_list.T], axis=0)
    
    # shape tensor energy
    edges = cells - jnp.roll(cells, 1, axis=0)
    lengths = jnp.sqrt(jnp.sum(edges**2, axis=-1)+epsilon_l[0]**2)
    # + epsilon**2 to avoid non-differentiable sqrt at 0-length edges (occurs due to padding)
    units = (edges.T/lengths.T).T
    delta = jnp.einsum('efi,efj->fij', edges, units) - rest_shape
    E_shape = jnp.mean(mod_shear*jnp.sum(delta**2, axis=(1,2)) + 
                       mod_bulk*(delta[:,0,0]+delta[:,1,1])**2)
    
    # vertex-model elasticity
    areas = tns.polygon_area(cells.transpose((0,2,1)))
    perimeters = tns.polygon_perimeter(cells.transpose((0,2,1)), epsilon_l=epsilon_l[0])
    E_vertex = jnp.mean(mod_area*(areas-A0)**2 + mod_perimeter*(perimeters-P0)**2)

    # angle penalty
    e_primal = pts[e_lst_primal[:,1],:] - pts[e_lst_primal[:,0],:] # he.twin.face-he.face
    lengths = jnp.sqrt(jnp.sum(e_primal**2, axis=-1)+epsilon_l[1]**2)
    lengths_dual = jnp.linalg.norm(e_dual, axis=-1)
    # + epsilon to avoid 0-division error and make penalty smooth as length passes through 0
    E_angle = jnp.mean(angle_penalty*(1-jnp.einsum('ie,ie->e', e_primal.T/lengths, e_dual.T/lengths_dual)))
    # note: non-zero epsilon creates a "penalty" against 0-length edges because 
    
    # boundary conditions
    E_bdry = 0
    for bdry in bdry_list:
        centroids = (jnp.sum(cells[:,bdry[1]].T*valence_mask[bdry[1]], axis=-1)
                     /jnp.sum(valence_mask[bdry[1]],axis=-1))
        E_bdry = E_bdry + bdry_penalty*jnp.sum(bdry[0](centroids)) # shape (2, n_cells_in_bdry)
        

    
    return E_shape + E_vertex + E_angle + E_bdry

get_E_jac = jit(jgrad(get_E))

# %% ../03_real_shape_optimization.ipynb 61
@patch
def optimize_cell_shape(self: CellHalfEdgeMesh,
                        energy_args=None, cell_id_to_modulus=None, cell_attribs=('rest_shape',),
                        edge_id_to_angle_penalty=None,
                        tol=1e-3, maxiter=10000, verbose=True, bdr_weight=2, return_sol=False) -> None:
    """
    Set primal vertex positions by constrained cell-shape energy optimization.
    
    To do: update to be able to change also the ratio of shear and bulk mod in the different regions!
    
    The parameters for the elastic energy (e.g. moduli) are passed as a dict 'energy_args'.
    self.bdry_list contains the boundary conditions, as pairs (penalty function, vertex ids).
    Also passes arguments to the scipy optimizer ('tol', 'maxiter').
    
    If a parameter is passed via 'energy_args' that is also provided by a mesh attribute
    (e.g. the cell reference shape tensor), the 'energy_args' overrides the mesh attribute
    and a warning is printed

    cell_id_to_modulus can be used to pattern the elastic moduli of the cells. It is a function
    that maps _vid -> [0, 1], i.e. vertex IDs to the strength of the elastic energy with 1=100%,
    and 0=no contribution of cell to elastic energy. All elastic moduli (shear, bulk, area)
    are multiplied with the same factor.
        
    Parameters
    ----------
    energy_args: Dict
        Dictionary with the parameters to the cell shape elastic energy. Keys are:
            - mod_bulk = 0 : shape tensor bulk modulus
            - mod_shear = 0 : shape tensor shear modulus
            - mod_area = 0 : area elasticity modulus
            - A0 = np.sqrt(3)/2 : reference area
            - mod_perimter = 0 : perimeter elasticity modulus
            - P0 = 2*np.sqrt(3) : reference perimeter
            - angle_penalty = 1000 : angle constraint penalty
            - bdry_penalty = 1000 : boundary condition constraint penalty
            - epsilon_l = (1e-3, 1e-3) : regularization for small edge lengths
    cell_id_to_modulus: callable or dict of callables
        Map vertex id -> relative elastic modulus. If None, all cells have the same moduli.
        If this is a dictionary, assumes that there is such a map for each modulus,
        i.e. 'mod_bulk', 'mod_shear', 'mod_area', 'mod_perimeter'.
    edge_id_to_angle_penalty: callable or None
        If not None, is used to create a different angle penalty for each edge.
        In this case, it needs to be a callable edge id -> relative angle penalty.
    cell_attribs: tuple of str
        Mesh cell attributes to serialize
    tol: float
        Optimizer tolerance
    maxiter: int
        Maximum number of optimizer iterations
    verbose: bool
        Print error messages
    bdr_weight: float
        Slighly hacky: increase the weight of boundary cells in the elastic energy so that they do not
        collapse etc.
    return_sol: bool
        Return the solution dict created by the scipy optimizer
    Returns
    -------
    None
    
    """
    x0 = self.primal_vertices_to_vector()
    serialized_dict, cell_list_vids = self.serialize_primal(cell_attribs)

    # modify the moduli depending on the mesh attributes - 
    modified = {} if energy_args is None else deepcopy(energy_args)
    if cell_id_to_modulus is not None:
        for key in ['mod_bulk', 'mod_shear', 'mod_area', 'mod_perimeter']:
            if key in modified:
                if isinstance(cell_id_to_modulus, dict):
                    modified[key] = modified[key]*np.vectorize(cell_id_to_modulus[key])(cell_list_vids)
                else:
                    modified[key] = modified[key]*np.vectorize(cell_id_to_modulus)(cell_list_vids)

    if bdr_weight != 1:
        is_bdr = np.array([any([fc.is_bdry() for fc in self.vertices[v].faces])
                           for v in cell_list_vids])
        for key in ['mod_bulk', 'mod_shear', 'mod_area', 'mod_perimeter']:
            if key in modified:
                modified[key] = modified[key]*(bdr_weight*is_bdr+(1-is_bdr))
    for key in modified.keys():
        if key in serialized_dict.keys():
            print(f'Overriding mesh values for {key} with manually provided value')
    # new: modify the angle penalty
    if edge_id_to_angle_penalty is not None:
        hes = np.array([key for key, he in sorted(self.hes.items())
                        if not he.is_bdry() and he.duplicate]) # from get_E
        modified["angle_penalty"] = modified["angle_penalty"]*np.vectorize(edge_id_to_angle_penalty)(hes)
        
    args = kwargs_to_args(get_E, serialized_dict | modified)
    sol = optimize.minimize(get_E, x0, jac=get_E_jac, args=args,
                            method="CG", tol=tol, options={"maxiter": maxiter})
    if sol["status"] !=0 and verbose:
        print("Cell shape optimization failed", sol["message"])
    new_coord_dict = self.vector_to_primal_vertices(sol["x"])
    for key, val in self.faces.items():
        val.primal_coords = new_coord_dict[key]
    if return_sol:
        return sol

# %% ../03_real_shape_optimization.ipynb 69
def rotate_about_center(x: NDArray[Shape["*,2"],Float], angle=np.pi/2):
    """
    Rotate points about center of mass. x.shape = (n_pts, 2).
    
    Used to rotate vertex positions post T1 to get a better new initial condition.
    """
    center = np.mean(x, axis=0)
    return (x-center)@dln.rot_mat(angle)+center

# %% ../03_real_shape_optimization.ipynb 70
@patch
def get_flip_edge(self: CellHalfEdgeMesh, minimal_l: float, exclude: List[int]) -> Union[int, None]:
    """
    Get key of the shortest primal edge in mesh if length < minimal_l and key not in exclude, else None.
    """
    
    primal_lengths = self.get_primal_edge_lens(oriented=True)
    primal_lengths = sorted(primal_lengths.items(), key=lambda x: x[1])
    primal_lengths = [x for x in primal_lengths if (x[1] <= minimal_l)]
    primal_lengths = [x for x in primal_lengths if not x[0] in exclude]
    if primal_lengths:
        return primal_lengths[0][0]
    return None

# %% ../03_real_shape_optimization.ipynb 71
@patch
def intercalate(self: CellHalfEdgeMesh, exclude: List[int], minimal_l: float,
                reoptimize=True, method_tension_post_t1="smooth", optimizer_args=None) -> Tuple[List, List]:
    """
    Intercalate short junctions and return list of (failed) intercalations.
    
    Iteratively flip edges shorter than minimal_l. After each edge flip,
    optionally re-run cell shape optimization. If so, need to pass the relevant
    arguments to self.optimize_cell_shape. Note: intercalations can fail if
    flipping would result in invalid mesh configs, e.g. flipping a boundary
    edge or an edge of a triangular cell.
    
    Parameters
    ----------
    exclude: list of ints
        list of half edge ids to exclude, e.g. edges which were flipped
        in a previous time step
    minimal_l: float
        Edges shorter than minimal_l are flipped
    reoptimize: bool
        Re-run shape optimization after each edge flip
    optimizer_args: dict
        Dictionary with the arguments for cell shape optimization, see
        docstring for self.optimize_cell_shape
            - bdry_list
            - energy_args
            - cell_id_to_modulus
            - tol, maxiter
    method_tension_post_t1 : str, either "smooth" or "direct"
        How to set active tensions post T1

    Returns
    -------
    flipped: list of int
        IDs of flipped edges
    failed_flip: list of int
        IDs of failed flips
    
    """
    optimizer_args = {} if optimizer_args is None else optimizer_args
    
    exclude = deepcopy(exclude)
    flipped = []
    failed_flip = []
    flip_edge = self.get_flip_edge(minimal_l, exclude)

    while flip_edge is not None:
        try:
            # flip and re-set the vertex coordinates
            he = self.hes[flip_edge]
            self.flip_edge(flip_edge)
            self.reset_rest_passive_flip(he, method=method_tension_post_t1)
            f0, f1 = (he.face, he.twin.face)
            f0.primal_coords, f1.primal_coords = rotate_about_center(np.stack([f0.primal_coords,
                                                                               f1.primal_coords]))
            # re-optimize
            if reoptimize:
                self.optimize_cell_shape(**optimizer_args)
            # log and choose next edge
            flipped.append(he._heid)
            exclude.append(he._heid)
            flip_edge = self.get_flip_edge(minimal_l, exclude)
            
        except ValueError:
            failed_flip.append(flip_edge)
            exclude.append(flip_edge)
            flip_edge = self.get_flip_edge(minimal_l, exclude)
            continue

    return flipped, failed_flip
