# AUTOGENERATED! DO NOT EDIT! File to edit: ../06_isogonal_hessian.ipynb.

# %% auto 0
__all__ = ['get_E_hessian', 'get_isogonal_trafo', 'top_q_share']

# %% ../06_isogonal_hessian.ipynb 2
import CE_simulation.mesh as msh
import CE_simulation.tension as tns
import CE_simulation.delaunay as dln
import CE_simulation.isogonal as iso

# %% ../06_isogonal_hessian.ipynb 3
import os
import sys

import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

from scipy import optimize, ndimage, sparse

from tqdm.notebook import tqdm

from copy import deepcopy
import pickle

# %% ../06_isogonal_hessian.ipynb 4
from typing import Union, Dict, List, Tuple, Iterable, Callable, Any
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../06_isogonal_hessian.ipynb 5
import jax.numpy as jnp
from jax import jit
import jax
from jax.tree_util import Partial

from jax.config import config
config.update("jax_enable_x64", True) # 32 bit leads the optimizer to complain about precision loss
config.update("jax_debug_nans", False) # useful for debugging, but makes code slower!

# %% ../06_isogonal_hessian.ipynb 6
import ipywidgets as widgets
import functools
from matplotlib import animation, rc

# %% ../06_isogonal_hessian.ipynb 10
@patch
def get_isogonal(self: msh.Vertex) -> Dict[int, NDArray[Shape["2"], Float]]:
    """
    Get isogonal mode for a given cell.
    
    Returns a dict: {faceid: translation vector} of primal vertices. Entries are
    
    j: T_j,bc / S_{self}bc
    
    where self,b,c are the three cells meeting at vertex j, and S is the area of the tension triangle.
    T_j is pointing towards vertex j (i.e. inwards)
    
    """

    # iterate over faces (cell vertices) adjacent to self. note: these are ccwise ordered by construction.
    isogonal_dict = {}
    for fc in self.faces:
        if fc is not None:
            S = fc.get_area()
            he = next(he for he in fc.hes if not self in he.vertices)            
            # note: hes are oriented ccwise
            T = dln.rot_mat(-np.pi/2)@(he.vertices[1].coords - he.vertices[0].coords)
            isogonal_dict[fc._fid] = T/S
        
    return isogonal_dict

# %% ../06_isogonal_hessian.ipynb 19
@patch
def get_isogonal_transform_matrix(self: msh.HalfEdgeMesh, flattened=False) -> NDArray[Shape["*,*,2"], Float]:
    """
    Create a matrix that transforms isogonal modes to vertex displacement
    
    To do the basis conversion, order vertices (cells) and faces (cell vertices) according to their indices.
    
    If flattened, flatten by combining face & x/y-component index
    
    """    
    face_key_dict = {key: ix for ix, key in enumerate(sorted(self.faces.keys()))}
    vertex_key_dict = {key: ix for ix, key in enumerate(sorted(self.faces.keys()))}
    
    iso_matrix = np.zeros((len(self.vertices), len(self.faces), 2))
    iso_dicts = {key: val.get_isogonal() for key, val in self.vertices.items()}

    for vkey, iso_dict in iso_dicts.items():
        for fkey, dr in iso_dict.items():
            iso_matrix[vertex_key_dict[vkey], face_key_dict[fkey], :] = dr
    if flattened:
        return iso_matrix.reshape((iso_matrix.shape[0], iso_matrix.shape[1]*iso_matrix.shape[2]))
    return iso_matrix

# %% ../06_isogonal_hessian.ipynb 35
def get_isogonal_trafo(mesh: msh.HalfEdgeMesh, mesh_ref=None) -> Dict[int, float]:
    """
    Get isogonal trafo from mesh_ref->mesh, or, if mesh_ref is None, from isogonal reference to mesh.
    
    By convention, the sum of all isogonal modes is set to 0. Results are returned as a dict {vertex: theta}.
    """
    if mesh_ref is None:
        mesh_ref = deepcopy(mesh_ref)
        mesh_ref.set_voronoi()
    
    x = mesh.primal_vertices_to_vector()
    x_ref = mesh_ref.primal_vertices_to_vector()

    theta_lstsq = np.linalg.lstsq(iso_matrix.T, x-x_ref, rcond=None)[0]
    theta_lstsq -= theta_lstsq.mean()

    return mesh.vector_to_vertices(theta_lstsq)
    

# %% ../06_isogonal_hessian.ipynb 38
get_E_hessian = jit(jax.hessian(iso.get_E))

# %% ../06_isogonal_hessian.ipynb 56
def top_q_share(x, q=.9):
    return np.round(x[x > np.quantile(x, q)].sum() / x.sum(), decimals=2)
