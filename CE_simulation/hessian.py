# AUTOGENERATED! DO NOT EDIT! File to edit: ../06_isogonal_hessian.ipynb.

# %% auto 0
__all__ = ['get_E_hessian', 'get_E_Theta_jac', 'deflatten', 'get_isogonal_trafo', 'get_quartet_isogonal_trafo', 'get_traceless',
           'get_E_Theta']

# %% ../06_isogonal_hessian.ipynb 2
import CE_simulation.mesh as msh
import CE_simulation.tension as tns
import CE_simulation.delaunay as dln
import CE_simulation.isogonal as iso
import CE_simulation.disorder as dso

# %% ../06_isogonal_hessian.ipynb 3
import os
import sys

import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

from scipy import optimize, ndimage, sparse

from tqdm.notebook import tqdm

from copy import deepcopy
import pickle

# %% ../06_isogonal_hessian.ipynb 4
from typing import Union, Dict, List, Tuple, Iterable, Callable, Any
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../06_isogonal_hessian.ipynb 5
import jax.numpy as jnp
from jax import jit
import jax
from jax.tree_util import Partial

from jax.config import config
config.update("jax_enable_x64", True) # 32 bit leads the optimizer to complain about precision loss
config.update("jax_debug_nans", False) # useful for debugging, but makes code slower!

# %% ../06_isogonal_hessian.ipynb 6
import ipywidgets as widgets
import functools
from matplotlib import animation, rc

# %% ../06_isogonal_hessian.ipynb 7
from collections import defaultdict

# %% ../06_isogonal_hessian.ipynb 11
@patch
def get_isogonal(self: msh.Vertex) -> Dict[int, NDArray[Shape["2"], Float]]:
    """
    Get isogonal mode for a given cell.
    
    Returns a dict: {faceid: translation vector} of primal vertices. Entries are
    
    j: T_j,bc / S_{self}bc
    
    where self,b,c are the three cells meeting at vertex j, and S is the area of the tension triangle.
    T_j is pointing towards vertex j (i.e. inwards)
    
    """

    # iterate over faces (cell vertices) adjacent to self. note: these are ccwise ordered by construction.
    isogonal_dict = {}
    for fc in self.faces:
        if fc is not None:
            S = fc.get_area()
            he = next(he for he in fc.hes if not self in he.vertices)            
            # note: hes are oriented ccwise
            T = dln.rot_mat(-np.pi/2)@(he.vertices[1].coords - he.vertices[0].coords)
            isogonal_dict[fc._fid] = T/S
        
    return isogonal_dict

# %% ../06_isogonal_hessian.ipynb 19
@patch
def get_isogonal_transform_matrix(self: msh.HalfEdgeMesh, flattened=False) -> NDArray[Shape["*,*,2"], Float]:
    """
    Create a matrix that transforms isogonal modes to vertex displacement
    
    To do the basis conversion, order vertices (cells) and faces (cell vertices) according to their indices.
    
    If flattened, flatten by combining face & x/y-component index
    
    """    
    face_key_dict = {key: ix for ix, key in enumerate(sorted(self.faces.keys()))}
    vertex_key_dict = {key: ix for ix, key in enumerate(sorted(self.vertices.keys()))}
    
    iso_matrix = np.zeros((len(self.vertices), len(self.faces), 2))
    iso_dicts = {key: val.get_isogonal() for key, val in self.vertices.items()}
    
    for vkey, iso_dict in iso_dicts.items():
        for fkey, dr in iso_dict.items():
            iso_matrix[vertex_key_dict[vkey], face_key_dict[fkey], :] = dr
    if flattened:
        return iso_matrix.reshape((iso_matrix.shape[0], iso_matrix.shape[1]*iso_matrix.shape[2]))
    return iso_matrix

# %% ../06_isogonal_hessian.ipynb 25
def deflatten(x):
    return x.reshape((int(x.shape[0]/2),2))

# %% ../06_isogonal_hessian.ipynb 35
def get_isogonal_trafo(mesh: msh.HalfEdgeMesh, mesh_ref=None) -> Dict[int, float]:
    """
    Get isogonal trafo from mesh_ref->mesh, or, if mesh_ref is None, from isogonal reference to mesh.
    
    By convention, the sum of all isogonal modes is set to 0. Results are returned as a dict {vertex: theta}.
    """
    if mesh_ref is None:
        mesh_ref = deepcopy(mesh_ref)
        mesh_ref.set_voronoi()
    
    x = mesh.primal_vertices_to_vector()
    x_ref = mesh_ref.primal_vertices_to_vector()

    theta_lstsq = np.linalg.lstsq(iso_matrix.T, x-x_ref, rcond=None)[0]
    theta_lstsq -= theta_lstsq.mean()

    return mesh.vector_to_vertices(theta_lstsq)
    

# %% ../06_isogonal_hessian.ipynb 41
def get_quartet_isogonal_trafo(mesh):
    """Get the per-quartet isogonal deformation tensor I_iso, computed by least squares"""
    
    quartets = {key: [he.vertices[0], he.prev.vertices[0], he.vertices[1], he.twin.nxt.vertices[1]]
                for key, he in mesh.hes.items()}
    quartets = {key: val for key, val in quartets.items() if not any([v.is_bdry() for v in val])}

    centroids = {key: np.stack([v.get_centroid() for v in val]) for key, val in quartets.items()}
    centroids = {key: val-val.mean(axis=0) for key, val in centroids.items()}

    vertices = {key: np.stack([v.coords for v in val]) for key, val in quartets.items()}
    vertices = {key: val-val.mean(axis=0) for key, val in vertices.items()}

    isogonal_trafo = {key: np.linalg.lstsq(val, centroids[key], rcond=None)[0] for key, val in vertices.items()}

    return isogonal_trafo

def get_traceless(matrix):
    """Get traceless symmetric part of matrix"""
    d = matrix.shape[0]
    return (matrix+matrix.T)/2 - np.trace(matrix)/d * np.eye(d)

# %% ../06_isogonal_hessian.ipynb 48
get_E_hessian = jit(jax.hessian(iso.get_E))

# %% ../06_isogonal_hessian.ipynb 102
@jit
def get_E_Theta(Theta0, e_lst_primal, e_dual, cell_list, bdry_list, valence_mask, iso_matrix, voronoi,
                mod_bulk=0, mod_shear=0, rest_shape=np.sqrt(3)*np.eye(2),
                mod_area=0, A0=np.sqrt(3)/2, mod_perimeter=0, P0=2*np.sqrt(3),
                angle_penalty=1000, bdry_penalty=1000, epsilon_l=(1e-3, 1e-3)):
    """Copy of iso.get_E, using isogonal parameters instead"""
    return iso.get_E(voronoi+Theta0 @ iso_matrix,
                     e_lst_primal, e_dual, cell_list, bdry_list, valence_mask,
                     mod_bulk=mod_bulk, mod_shear=mod_shear, rest_shape=rest_shape,
                     mod_area=mod_area, A0=A0, mod_perimeter=mod_perimeter, P0=P0,
                     angle_penalty=angle_penalty, bdry_penalty=bdry_penalty, epsilon_l=epsilon_l)
        
get_E_Theta_jac = jit(jax.grad(get_E_Theta))

# %% ../06_isogonal_hessian.ipynb 107
@patch
def get_voronoi_metric(self: msh.Vertex):
    if not self.is_bdry():
        Ts = np.stack([he.vertices[0].coords-self.coords for he in self.incident])
        metric = 2 * np.einsum('ai,aj->ij', Ts, Ts) / Ts.shape[0]
    else:
        metric = np.eye(2) # in principle, need something better, e.g. mirroring across the boundary
    return metric
