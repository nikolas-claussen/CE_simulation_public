# AUTOGENERATED! DO NOT EDIT! File to edit: ../04b_boundary_conditions_jax_experimentation.ipynb.

# %% auto 0
__all__ = ['get_triangular_lattice', 'create_rect_mesh', 'get_E', 'excitable_dt_act_pass']

# %% ../04b_boundary_conditions_jax_experimentation.ipynb 3
from .triangle import *
from .tension import *
from .delaunay import *
from .isogonal import *

# %% ../04b_boundary_conditions_jax_experimentation.ipynb 4
import os
import sys
import importlib

import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.collections import LineCollection

from numpy import sin, cos, tan, pi, sqrt, arccos, arctan, arctan2
from numpy.linalg import norm

from scipy.integrate import solve_ivp
from scipy import ndimage
from scipy import spatial
from scipy import optimize

from tqdm.notebook import tqdm

from copy import deepcopy

from collections import Counter, defaultdict

# %% ../04b_boundary_conditions_jax_experimentation.ipynb 5
from dataclasses import dataclass
from typing import Union, Dict, List, Tuple, Iterable, Callable
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../04b_boundary_conditions_jax_experimentation.ipynb 6
import ipywidgets as widgets
from matplotlib import animation, rc

# %% ../04b_boundary_conditions_jax_experimentation.ipynb 7
import autograd.numpy as anp  # Thinly-wrapped numpy
from autograd import grad as agrad

# %% ../04b_boundary_conditions_jax_experimentation.ipynb 9
def get_triangular_lattice(nx, ny):
    """get triangular lattice with nx, ny points. Return a mask which delinates bdry vertices""" 

    y = np.arange(0, ny)*sqrt(3)/2
    x = np.arange(nx).astype(float)
    X, Y = np.meshgrid(x, y)
    X -= X.mean()+1/2; Y -=Y.mean()
    X = (X.T+(np.arange(ny)%2)/2).T
    pts = np.stack([X, Y]).reshape((2,nx*ny))
    is_bdry = np.zeros_like(X)
    is_bdry[:1] = is_bdry[-1:] = 1
    is_bdry[:,:1] = is_bdry[:,-1:] = 1
    is_bdry = is_bdry.reshape(nx*ny)
    
    return pts, is_bdry

def create_rect_mesh(nx, ny, noise=0, defects=(0,0), straight_bdry=False):
    pts, is_bdry = get_triangular_lattice(nx, ny)
    pts[:,~is_bdry.astype(bool)] += np.random.normal(scale=noise, size=(2, (~is_bdry.astype(bool)).sum()))
    if defects[0] > 0:
        ix = np.random.choice(np.where(1-is_bdry)[0], size=defects[0], replace=False)
        pts = np.delete(pts, ix, axis=1)
    if defects[1] > 0:
        ix = np.random.choice(np.where(1-is_bdry)[0], size=defects[1], replace=False)
        split = np.random.choice((0,1), len(ix))
        additional_pts =  pts[:, ix] + .3*np.stack([1-split, split]) 
        pts[:, ix] -= .3*np.stack([1-split, split]) 
        pts = np.hstack([pts, additional_pts])
    
    tri = spatial.Delaunay(pts.T)
    # remove the left, right edge
    if straight_bdry:
        simplices = tri.simplices
    else:
        max_x, min_x = (pts[0].max(), pts[0].min())
        simplices = np.stack([x for x in tri.simplices
                          if (np.isclose(pts[0,x], min_x).sum()<2) and (np.isclose(pts[0,x], max_x).sum()<2)])
    pre_mesh = ListOfVerticesAndFaces(tri.points, simplices)
    mesh = HalfEdgeMesh(pre_mesh)
    
    return mesh

# might want to add the corner pts.

# %% ../04b_boundary_conditions_jax_experimentation.ipynb 14
@patch
def get_primal_energy_fct_jax(self: HalfEdgeMesh, mod_bulk=1, mod_shear=.01, angle_penalty=100,
                               epsilon_l=1e-5):
    """Get function to compute primal energy from primal vertices. Cell based shape tensor.
    bdry_penalty_fcts: (2, ...) -> energy. bdry_ids = [vertex id,]
    """

    # book-keeping
    face_keys = sorted(self.faces.keys())
    face_key_dict = {key: ix for ix, key in enumerate(sorted(self.faces.keys()))}
    n_faces = len(self.faces)
    
    # stuff for the shape tensor energy
    cell_list = []
    rest_shapes = []
    for v in self.vertices.values():    # iterate around vertex.
        neighbors = v.get_face_neighbors()
        if not (None in neighbors):
            cell = jnp.array([face_key_dict[fc._fid] for fc in neighbors])
            cell_list.append(cell)
            rest_shapes.append(v.rest_shape)
    valences = [len(cell) for cell in cell_list]
    max_valence = max(valences)
    valence_mask = anp.array([x*[0,]+(max_valence-x)*[1,] for x in valences])
    cell_list = jnp.array([anp.pad(cell, (0, max_valence-len(cell)), mode="edge") for cell in cell_list])
    rest_shapes = jnp.stack(rest_shapes)

    # stuff for the angle penalty
    e_dual = [] # dual vertices do not move during optimization, so collect the actual edges
    e_lst_primal = [] # for primal, collect the indices

    for he in self.hes.values():
        if (he.face is not None) and (he.twin.face is not None) and he.duplicate:
            dual_edge = he.vertices[1].coords-he.vertices[0].coords
            # rotate by 90 degrees
            dual_edge = jnp.array([dual_edge[1], -dual_edge[0]])
            dual_edge = dual_edge / np.linalg.norm(dual_edge)
            primal_edge = [face_key_dict[fc._fid] for fc in [he.face, he.twin.face]] # 0= he, 1= twin
            e_dual.append(dual_edge)
            e_lst_primal.append(primal_edge)
    e_dual = jnp.array(e_dual)
    e_lst_primal = jnp.array(e_lst_primal)
    
    return e_lst_primal, e_dual, cell_list
    
@jit 
def get_E(x0, e_lst_primal, e_dual, cell_list):
    epsilon_l = 1e-3
    n_faces = int(x0.shape[0]/2)
    x, y = (x0[:n_faces], x0[n_faces:])
    pts = jnp.stack([x, y], axis=-1)
    # face-based shape energy
    cells = jnp.stack([pts[i] for i in cell_list.T], axis=0)
    edges = cells - jnp.roll(cells, 1, axis=0)
    lengths = jnp.linalg.norm(edges, axis=-1) + epsilon_l  #(edges.T + valence_mask).T
    # stupid hack to avoid 0-division error due to padding in the jacobian
    units = (edges.T/lengths.T).T
    tensors = jnp.einsum('efi,efj->fij', edges, units)  # units
    delta = tensors - jnp.sqrt(3)*jnp.array([[1.,0],[0,1.]], dtype=jnp.float32)
    E_shape = (4*jnp.mean(delta**2) + jnp.mean((delta[:,0,0]+delta[:,1,1])**2))
    # angle penalty|
    e_primal = pts[e_lst_primal[:,1],:] - pts[e_lst_primal[:,0],:] # he.twin.face-he.face
    lengths = jnp.linalg.norm(e_primal, axis=-1)+epsilon_l
    # + epsilon to avoid 0-division error and make penalty smooth as length passes through 0
    #penalty = jnp.einsum('ei,ei->e', e_primal, e_dual)**2
    penalty = (1-jnp.einsum('ei,ei->e', e_primal, e_dual)/lengths)
    #penalty = lengths-jnp.einsum('ei,ei->e', e_primal, e_dual)
    
    E_angle = 100 * anp.mean(penalty) 
    return E_shape + E_angle


# %% ../04b_boundary_conditions_jax_experimentation.ipynb 47
def excitable_dt_act_pass(Ts, Tps, k=1, m=2):
    """Time derivative of tensions under excitable tension model with constrained area,
    with passive tension for post intercalation. Variant: completely deactivate feedback for m=1"""
    dT_dt = (m-1)*((Ts-Tps)**m - k*Tps)
    dTp_dt = -k*Tps
    area_jac = sides_area_jac(Ts-Tps)
    area_jac /= norm(area_jac)
    dT_dt -= area_jac * (area_jac@dT_dt)
    return dT_dt, dTp_dt

