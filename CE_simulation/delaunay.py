# AUTOGENERATED! DO NOT EDIT! File to edit: ../02_delaunay_simulation.ipynb.

# %% auto 0
__all__ = ['rot_mat', 'shear_mat', 'scale_mat', 'get_inertia', 'get_triangular_lattice_convex',
           'get_triangular_lattice_convex_alt', 'get_tri_hemesh', 'voronoi_plot_2d_bdry', 'get_circumcenter',
           'get_voronoi_pos']

# %% ../02_delaunay_simulation.ipynb 3
from .triangle import *
from .tension import *

# %% ../02_delaunay_simulation.ipynb 4
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

from numpy import sin, cos, tan, pi, sqrt, arccos, arctan, arctan2
from numpy.linalg import norm

from scipy.integrate import solve_ivp
from scipy import ndimage
from scipy import spatial
from scipy import optimize

from tqdm.notebook import tqdm

from math import floor, ceil

import sys

from copy import deepcopy

# %% ../02_delaunay_simulation.ipynb 5
from dataclasses import dataclass
from typing import Union, Dict, List, Tuple, Iterable, Callable
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../02_delaunay_simulation.ipynb 7
# geometric transform matrices

def rot_mat(theta):
    return np.array([[cos(theta), sin(theta)],[-sin(theta), cos(theta)]])

def shear_mat(s):
    return np.array([[s, 0],[0, 1/s]])

def scale_mat(s):
    return np.diag([s,s])

# %% ../02_delaunay_simulation.ipynb 8
def get_inertia(pts):
    """Pts = (n_points, 2)"""
    pts -= pts.mean(axis=0)
    x, y = pts.T
    Ixx = (x**2).mean()
    Ixy = (x*y).mean()
    Iyy = (y**2).mean()
    return np.array([[Ixx, Ixy], [Ixy,Iyy]])
    

# %% ../02_delaunay_simulation.ipynb 9
## Creating initial conditions - triangular lattice

def get_triangular_lattice_convex(nx, ny):

    assert nx%2

    y = np.arange(0, ny).astype(float)
    x = np.arange(nx)*sqrt(3)/2
    X, Y = np.meshgrid(x, y)
    Y = (Y+(np.arange(nx)%2)/2)
    X -= X.mean(); Y -=Y.mean()
    pts = np.stack([X, Y]).reshape((2,nx*ny))
    
    theta = 30
    thr = ceil(nx/4)
    halfplanes = [np.array([sin(pi/180*theta), cos(pi/180*theta)]),
                  np.array([sin(-pi/180*theta), cos(-pi/180*theta)])]
    vals = halfplanes[0].dot(pts)
    sorted_vals = np.sort(vals)
    is_convex = (vals > sorted_vals[thr]+1e-3) & (vals < sorted_vals[-(thr+1)]-1e-3)
    vals = halfplanes[1].dot(pts)
    sorted_vals = np.sort(vals)
    is_convex &= (vals > sorted_vals[thr]+1e-3) & (vals < sorted_vals[-(thr+1)]-1e-3)

    return pts[:, is_convex]

def get_triangular_lattice_convex_alt(nx, ny, convexify=True):

    assert ny%2 and nx%2 #and 2*ny > nx

    max_ny = 2*(nx-1)+1
    ny = min(ny, max_ny)
    
    y = np.arange(0, ny)*sqrt(3)/2
    x = np.arange(nx).astype(float)
    X, Y = np.meshgrid(x, y)

    X -= X.mean()+1/2; Y -=Y.mean()

    X = (X.T+(np.arange(ny)%2)/2).T
    pts = np.stack([X, Y]).reshape((2,nx*ny))
    
    theta = 60
    epsilon = 1e-4
    thr = floor(ny/4)
    halfplanes = [np.array([sin(pi/180*theta), cos(pi/180*theta)]),
                  np.array([sin(-pi/180*theta), cos(-pi/180*theta)])]
    vals = halfplanes[0].dot(pts)
    in_0_row = vals[np.abs(pts[1]) < epsilon]    
    is_convex = (vals > in_0_row.min()-epsilon) & (vals < in_0_row.max()+epsilon)
    
    vals = halfplanes[1].dot(pts)
    in_0_row = vals[np.abs(pts[1]) < epsilon]    
    is_convex &= (vals > in_0_row.min()-epsilon) & (vals < in_0_row.max()+epsilon)
    
    if convexify:
        pts = pts[:, is_convex]
        pts = (pts.T-pts.mean(axis=1)).T
        return pts
    return pts

def get_tri_hemesh(nx=7, ny=11, noise=0):
    pts = get_triangular_lattice_convex_alt(nx, ny)
    tri = spatial.Delaunay(pts.T)
    mesh = HalfEdgeMesh(ListOfVerticesAndFaces(tri.points, tri.simplices))
    mesh.transform_vertices(lambda x: x+np.random.normal(scale=noise, size=(2,)))
    return mesh

# %% ../02_delaunay_simulation.ipynb 11
from scipy.spatial._plotutils import _adjust_bounds
from matplotlib.collections import LineCollection

def voronoi_plot_2d_bdry(vor, bdry=None, plot_infinite=False, ax=None, **kw):
    """
    Plot the given Voronoi diagram in 2-D, with the possibility of leaving out bdries.
    "Forked" from github.com/scipy/scipy/blob/v1.9.1/scipy/spatial/_plotutils.py
    Parameters
    ----------
    vor : scipy.spatial.Voronoi instance
        Diagram to plot
    ax : matplotlib.axes.Axes instance, optional
        Axes to plot on
    show_points : bool, optional
        Add the Voronoi points to the plot.
    show_vertices : bool, optional
        Add the Voronoi vertices to the plot.
    line_colors : string, optional
        Specifies the line color for polygon boundaries
    line_width : float, optional
        Specifies the line width for polygon boundaries
    line_alpha : float, optional
        Specifies the line alpha for polygon boundaries
    point_size : float, optional
        Specifies the size of points
    plot_infinite : bool, optional
        plot edges to infinity
    Returns
    -------
    fig : matplotlib.figure.Figure instance
        Figure for the plot
    See Also
    --------
    Voronoi
    Notes
    -----
    Requires Matplotlib.
    Examples
    --------
    Set of point:
    >>> import matplotlib.pyplot as plt
    >>> rng = np.random.default_rng()
    >>> points = rng.random((10,2))
    Voronoi diagram of the points:
    >>> from scipy.spatial import Voronoi, voronoi_plot_2d
    >>> vor = Voronoi(points)
    using `voronoi_plot_2d` for visualisation:
    >>> fig = voronoi_plot_2d(vor)
    using `voronoi_plot_2d` for visualisation with enhancements:
    >>> fig = voronoi_plot_2d(vor, show_vertices=False, line_colors='orange',
    ...                 line_width=2, line_alpha=0.6, point_size=2)
    >>> plt.show()
    """
    if ax is None:
        fig = plt.figure()
        ax = fig.gca()
    bdry = [] if bdry is None else bdry
    if vor.points.shape[1] != 2:
        raise ValueError("Voronoi diagram is not 2-D")

    if kw.get('show_points', True):
        point_size = kw.get('point_size', None)
        ax.plot(vor.points[:,0], vor.points[:,1], '.', markersize=point_size)
    if kw.get('show_vertices', True):
        ax.plot(vor.vertices[:,0], vor.vertices[:,1], 'o')

    line_colors = kw.get('line_colors', 'k')
    line_width = kw.get('line_width', 1.0)
    line_alpha = kw.get('line_alpha', 1.0)

    center = vor.points.mean(axis=0)
    ptp_bound = vor.points.ptp(axis=0)

    finite_segments = []
    infinite_segments = []
    for pointidx, simplex in zip(vor.ridge_points, vor.ridge_vertices):
        simplex = np.asarray(simplex)
        if all([x in bdry for x in pointidx]):
            continue
        if np.all(simplex >= 0):
            finite_segments.append(vor.vertices[simplex])
        else:
            i = simplex[simplex >= 0][0]  # finite end Voronoi vertex

            t = vor.points[pointidx[1]] - vor.points[pointidx[0]]  # tangent
            t /= np.linalg.norm(t)
            n = np.array([-t[1], t[0]])  # normal

            midpoint = vor.points[pointidx].mean(axis=0)
            direction = np.sign(np.dot(midpoint - center, n)) * n
            if (vor.furthest_site):
                direction = -direction
            far_point = vor.vertices[i] + direction * ptp_bound.max()

            infinite_segments.append([vor.vertices[i], far_point])

    ax.add_collection(LineCollection(finite_segments,
                                     colors=line_colors,
                                     lw=line_width,
                                     alpha=line_alpha,
                                     linestyle='solid'))
    if plot_infinite:
        ax.add_collection(LineCollection(infinite_segments,
                                         colors=line_colors,
                                         lw=line_width,
                                         alpha=line_alpha,
                                         linestyle='dashed'))

    _adjust_bounds(ax, vor.points)

    return ax.figure

# %% ../02_delaunay_simulation.ipynb 12
@patch
def voronoiplot(self: HalfEdgeMesh, **kw):
    bdry_vertices = sorted([he._verticesid[0] for he in self.hes.values() if he.face is None])
    vertex_keys = sorted([key for key in self.vertices.keys()])

    pts = np.array([self.vertices[v].coords for v in vertex_keys])
    vor = spatial.Voronoi(pts, furthest_site=False)
    
    voronoi_plot_2d_bdry(vor, bdry=bdry_vertices, show_vertices=False, show_points=False)

# %% ../02_delaunay_simulation.ipynb 25
@patch
def flatten_triangulation(self: HalfEdgeMesh, tol=1e-3, verbose=True):
    """Flatten triangulation"""
    get_E, grd = self.get_energy_fct()
    x0 = self.vertices_to_initial_cond()
    sol = optimize.minimize(get_E, x0, method="CG", jac=grd, tol=tol)
    if sol["status"] !=0 and verbose:
        print("Triangulation optimization failed")
        print(sol["message"])
    new_coord_dict = self.initial_cond_to_vertices(sol["x"])
    for key, val in self.vertices.items():
        val.coords = new_coord_dict[key]
    self.set_rest_lengths()

@patch
def euler_step(self: HalfEdgeMesh, dt=.005, rhs=excitable_dt_post, params=None):
    """RHS: callable Ts, Tps -> dTs_dt, dTps_dt"""
    for fc in self.faces.values():
        # collect edges
        Ts, Tps = (np.array([he.rest for he in fc.hes]), np.array([he.passive for he in fc.hes]))
        dT_dt, dTp_dt = excitable_dt_post(Ts, Tps, **params)
        Ts += dt*dT_dt
        Tps += dt*dTp_dt
        for T, Tp, he in zip(Ts, Tps, fc.hes):
            he.rest = T
            he.passive = Tp

# %% ../02_delaunay_simulation.ipynb 30
def get_circumcenter(a, b, c):
    """Return circumcircle radius and circumcenter"""
    b_, c_ = (b-a, c-a)
    d_ = 2*(b_[0]*c_[1]-b_[1]*c_[0])
    u_ = np.array([c_[1]*(b_**2).sum()-b_[1]*(c_**2).sum(), b_[0]*(c_**2).sum()-c_[0]*(b_**2).sum()]) / d_
    r = norm(u_)
    return r, u_ + a

# %% ../02_delaunay_simulation.ipynb 32
def get_voronoi_pos(mesh):
    circumcenter_dict = {}
    for key, fc in mesh.faces.items():
        vecs = []
        returned = False
        start_he = fc.hes[0]
        he = start_he
        while not returned:
            vecs.append(he.vertices[0].coords)
            he = he.nxt
            returned = (he == start_he)
        _, circumcenter = get_circumcenter(*vecs)
        circumcenter_dict[key] = circumcenter
    return circumcenter_dict

@patch
def set_voronoi(self: HalfEdgeMesh):
    """Set dual positions to voronoi"""
    for fc in self.faces.values():
        vecs = []
        returned = False
        start_he = fc.hes[0]
        he = start_he
        while not returned:
            vecs.append(he.vertices[0].coords)
            he = he.nxt
            returned = (he == start_he)
        _, circumcenter = get_circumcenter(*vecs)
        fc.dual_coords = circumcenter
