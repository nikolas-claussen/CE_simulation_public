# AUTOGENERATED! DO NOT EDIT! File to edit: ../04_boundary_conditions.ipynb.

# %% auto 0
__all__ = ['mat_inv_2d', 'get_triangular_lattice', 'create_rect_mesh', 'excitable_dt_act_pass']

# %% ../04_boundary_conditions.ipynb 3
from .triangle import *
from .tension import *
from .delaunay import *
from .isogonal import *

# %% ../04_boundary_conditions.ipynb 4
import os
import sys
import importlib

import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.collections import LineCollection

from numpy import sin, cos, tan, pi, sqrt, arccos, arctan, arctan2
from numpy.linalg import norm

from scipy.integrate import solve_ivp
from scipy import ndimage
from scipy import spatial
from scipy import optimize

from tqdm.notebook import tqdm

from copy import deepcopy

from collections import Counter, defaultdict

# %% ../04_boundary_conditions.ipynb 5
from dataclasses import dataclass
from typing import Union, Dict, List, Tuple, Iterable, Callable
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../04_boundary_conditions.ipynb 6
import ipywidgets as widgets
from matplotlib import animation, rc

# %% ../04_boundary_conditions.ipynb 7
import autograd.numpy as anp  # Thinly-wrapped numpy
from autograd import grad as agrad

# %% ../04_boundary_conditions.ipynb 12
def mat_inv_2d(mat):
    """mat.shape = (i,j, ...)"""
    inv = 1/(mat[0,0]*mat[1,1]-mat[0,1]*mat[1,0])*anp.stack([[mat[1,1], -mat[0,1]],[-mat[1,0], mat[0,0]]])
    return inv

# %% ../04_boundary_conditions.ipynb 14
@patch
def get_primal_energy_fct_cells_bdry(self: HalfEdgeMesh, mod_bulk=1, mod_shear=.01, angle_penalty=100,
                                     reg_bulk=0, A0=sqrt(3)/2, epsilon_l=1e-5,
                                     bdry_penalty=20, bdry_ids=None, bdry_penalty_fcts=None, bdry_coords=None):
    """Get function to compute primal energy from primal vertices. Cell based shape tensor.
    bdry_penalty_fcts: (2, n_vertices) -> energy. Also replaced it by scale invariant energy.
    """
    bdry_method = None
    if bdry_penalty_fcts is not None:
        bdry_method = "penalty"
    elif bdry_coords is not None:
        bdry_method = "frozen"

    if bdry_ids is None:
        bdry_ids = []
        bdry_penalty_fcts = []
        bdry_coords = []
    # book-keeping
    face_keys = sorted(self.faces.keys())
    face_key_dict = {key: ix for ix, key in enumerate(sorted(self.faces.keys()))}
    n_faces = len(self.faces)
    
    # for bdry
    bdry_masks = [anp.array([(fid in ids) for fid in face_keys]) for ids in bdry_ids]
    bdry_ids = [anp.stack([face_key_dict[fid] for fid in ids]) for ids in bdry_ids]

    # stuff for the shape tensor energy
    cell_list = []
    rest_shapes = []
    for v in self.vertices.values():    # iterate around vertex.
        neighbors = v.get_face_neighbors()
        if not (None in neighbors):
            cell = [face_key_dict[fc._fid] for fc in neighbors]
            cell_list.append(cell)
            rest_shapes.append(v.rest_shape)
    valences = [len(cell) for cell in cell_list]
    max_valence = max(valences)
    valence_mask = anp.array([x*[0,]+(max_valence-x)*[1,] for x in valences])
    cell_list = anp.array([anp.pad(cell, (0, max_valence-len(cell)), mode="edge") for cell in cell_list])
    rest_shapes = anp.stack(rest_shapes)

    # stuff for the angle penalty
    e_dual = [] # dual vertices do not move during optimization, so collect the actual edges
    e_lst_primal = [] # for primal, collect the indices

    for he in self.hes.values():
        if (he.face is not None) and (he.twin.face is not None) and he.duplicate:
            dual_edge = he.vertices[1].coords-he.vertices[0].coords
            # rotate by 90 degrees
            dual_edge = anp.array([dual_edge[1], -dual_edge[0]])
            dual_edge = dual_edge / np.linalg.norm(dual_edge)
            primal_edge = [face_key_dict[fc._fid] for fc in [he.face, he.twin.face]] # 0= he, 1= twin
            e_dual.append(dual_edge)
            e_lst_primal.append(primal_edge)
    e_dual = anp.array(e_dual)
    e_lst_primal = anp.array(e_lst_primal)
    
    # breaking translational invariance.
    center = anp.mean([v.coords for v in self.vertices.values()], axis=0)
    
    def get_E(x0):
        x, y = (x0[:n_faces], x0[n_faces:])
        # freeze boundary
        if bdry_method == "frozen":
            for msk, coord in zip(bdry_masks, bdry_coords):
                if coord[0] == "x":
                    x = x*(1-msk) + msk*coord[1]
                elif coord[0] == "y":
                    y = y*(1-msk) + msk*coord[1]
        pts = anp.stack([x, y], axis=-1)
        # face-based shape energy
        cells = anp.stack([pts[i] for i in cell_list.T], axis=0)
        edges = cells - anp.roll(cells, 1, axis=0)
        lengths = anp.linalg.norm((edges.T + valence_mask).T, axis=-1) + 10*epsilon_l
        # stupid hack to avoid 0-division error due to padding in the jacobian
        units = (edges.T/lengths.T).T
        tensors = anp.einsum('efi,efj->fij', edges, units) 
        delta = tensors - rest_shapes
        #delta = anp.einsum('ijf, fjk->fik', mat_inv_2d(rest_shapes.T), tensors) - anp.eye(2)
        E_shape = (mod_shear*4*anp.mean(delta**2)
                   + mod_bulk*anp.mean((delta[:,0,0]+delta[:,1,1])**2))
        # regularize with the vertex model energy
        if reg_bulk > 0:
            E_vertex = reg_bulk*anp.mean((polygon_area(cells)-A0)**2)
        else:
            E_vertex = 0
        # angle penalty
        pts = anp.stack([x, y], axis=-1)
        e_primal = pts[e_lst_primal[:,1]] - pts[e_lst_primal[:,0]] # he.twin.face-he.face
        lengths = anp.linalg.norm(e_primal, axis=-1) 
        # + epsilon to avoid 0-division error and make penalty smooth as length passes through 0
        # makes energy barrier so need epsilon small!
        penalty = (1-anp.einsum('ei,ei->e', e_primal, e_dual)/(lengths+epsilon_l))
        E_angle = angle_penalty * anp.mean(penalty) 
        # break translation symmetry
        E_trans = 1/2*((anp.mean(x)-center[0])**2+(anp.mean(y)-center[0]))**2
        # boundary energy
        E_bdry = 0
        if bdry_method == "penalty":
            for ids, fct in zip(bdry_ids, bdry_penalty_fcts):
                E_bdry = E_bdry+bdry_penalty*anp.mean(fct(pts[ids,:].T))
        return E_angle + E_shape + E_vertex + E_trans + E_bdry
    
    return get_E, agrad(get_E)

# %% ../04_boundary_conditions.ipynb 15
@patch
def set_bdry(self: HalfEdgeMesh, bdry_ids, bdry_coords):
    for bdry, coord in zip(bdry_ids, bdry_coords):
        for fcid in bdry:
            if coord[0] =="x":
                self.faces[fcid].dual_coords[0] = coord[1]
            elif coord[0] =="y":
                self.faces[fcid].dual_coords[1] = coord[1]

# %% ../04_boundary_conditions.ipynb 29
def get_triangular_lattice(nx, ny):
    """get triangular lattice with nx, ny points. Return a mask which delinates bdry vertices""" 

    y = np.arange(0, ny)*sqrt(3)/2
    x = np.arange(nx).astype(float)
    X, Y = np.meshgrid(x, y)
    X -= X.mean()+1/2; Y -=Y.mean()
    X = (X.T+(np.arange(ny)%2)/2).T
    pts = np.stack([X, Y]).reshape((2,nx*ny))
    is_bdry = np.zeros_like(X)
    is_bdry[:1] = is_bdry[-1:] = 1
    is_bdry[:,:1] = is_bdry[:,-1:] = 1
    is_bdry = is_bdry.reshape(nx*ny)
    
    return pts, is_bdry

def create_rect_mesh(nx, ny, noise=0, defects=(0,0), straight_bdry=False):
    pts, is_bdry = get_triangular_lattice(nx, ny)
    pts[:,~is_bdry.astype(bool)] += np.random.normal(scale=noise, size=(2, (~is_bdry.astype(bool)).sum()))
    if defects[0] > 0:
        ix = np.random.choice(np.where(1-is_bdry)[0], size=defects[0], replace=False)
        pts = np.delete(pts, ix, axis=1)
    if defects[1] > 0:
        ix = np.random.choice(np.where(1-is_bdry)[0], size=defects[1], replace=False)
        split = np.random.choice((0,1), len(ix))
        additional_pts =  pts[:, ix] + .3*np.stack([1-split, split]) 
        pts[:, ix] -= .3*np.stack([1-split, split]) 
        pts = np.hstack([pts, additional_pts])
    
    tri = spatial.Delaunay(pts.T)
    # remove the left, right edge
    if straight_bdry:
        simplices = tri.simplices
    else:
        max_x, min_x = (pts[0].max(), pts[0].min())
        simplices = np.stack([x for x in tri.simplices
                          if (np.isclose(pts[0,x], min_x).sum()<2) and (np.isclose(pts[0,x], max_x).sum()<2)])
    pre_mesh = ListOfVerticesAndFaces(tri.points, simplices)
    mesh = HalfEdgeMesh(pre_mesh)
    
    return mesh

# might want to add the corner pts.

# %% ../04_boundary_conditions.ipynb 39
def excitable_dt_act_pass(Ts, Tps, k=1, m=2):
    """Time derivative of tensions under excitable tension model with constrained area,
    with passive tension for post intercalation. Variant: completely deactivate feedback for m=1"""
    dT_dt = (m-1)*((Ts-Tps)**m - k*Tps)
    dTp_dt = -k*Tps
    area_jac = sides_area_jac(Ts-Tps)
    area_jac /= norm(area_jac)
    dT_dt -= area_jac * (area_jac@dT_dt)
    return dT_dt, dTp_dt

