# AUTOGENERATED! DO NOT EDIT! File to edit: ../04_boundary_conditions.ipynb.

# %% auto 0
__all__ = []

# %% ../04_boundary_conditions.ipynb 3
from .triangle import *
from .tension import *
from .delaunay import *
from .isogonal import *

# %% ../04_boundary_conditions.ipynb 4
import os
import sys
import importlib

import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.collections import LineCollection

from numpy import sin, cos, tan, pi, sqrt, arccos, arctan, arctan2
from numpy.linalg import norm

from scipy.integrate import solve_ivp
from scipy import ndimage
from scipy import spatial
from scipy import optimize

from tqdm.notebook import tqdm

from copy import deepcopy

from collections import Counter, defaultdict

# %% ../04_boundary_conditions.ipynb 5
from dataclasses import dataclass
from typing import Union, Dict, List, Tuple, Iterable, Callable
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../04_boundary_conditions.ipynb 6
import ipywidgets as widgets
from matplotlib import animation, rc

# %% ../04_boundary_conditions.ipynb 7
import autograd.numpy as anp  # Thinly-wrapped numpy
from autograd import grad as agrad

# %% ../04_boundary_conditions.ipynb 18
@patch
def get_primal_energy_fct_cells_bdry(self: HalfEdgeMesh, mod_bulk=1, mod_shear=.01, angle_penalty=100,
                                     reg_bulk=0, A0=sqrt(3)/2, epsilon_l=1e-5,
                                     bdry_penalty=20, bdry_ids=None, bdry_penalty_fcts=None):
    """Get function to compute primal energy from primal vertices. Cell based shape tensor.
    bdry_penalty_fcts: (2, ...) -> energy. bdry_ids = [vertex id,]
    """

    if bdry_ids is None:
        bdry_ids = []
        bdry_penalty_fcts = []
    # book-keeping
    face_keys = sorted(self.faces.keys())
    face_key_dict = {key: ix for ix, key in enumerate(sorted(self.faces.keys()))}
    n_faces = len(self.faces)
    
    # for bdry - need to move this into cell
    bdry_ids = [[anp.stack([face_key_dict[fc._fid] for fc in self.vertices[v].get_face_neighbors()
                           if fc is not None]) for v in ids]
                for ids in bdry_ids]
    # stuff for the shape tensor energy
    cell_list = []
    rest_shapes = []
    for v in self.vertices.values():    # iterate around vertex.
        neighbors = v.get_face_neighbors()
        if not (None in neighbors):
            cell = [face_key_dict[fc._fid] for fc in neighbors]
            cell_list.append(cell)
            rest_shapes.append(v.rest_shape)
    valences = [len(cell) for cell in cell_list]
    max_valence = max(valences)
    valence_mask = anp.array([x*[0,]+(max_valence-x)*[1,] for x in valences])
    cell_list = anp.array([anp.pad(cell, (0, max_valence-len(cell)), mode="edge") for cell in cell_list])
    rest_shapes = anp.stack(rest_shapes)

    # stuff for the angle penalty
    e_dual = [] # dual vertices do not move during optimization, so collect the actual edges
    e_lst_primal = [] # for primal, collect the indices

    for he in self.hes.values():
        if (he.face is not None) and (he.twin.face is not None) and he.duplicate:
            dual_edge = he.vertices[1].coords-he.vertices[0].coords
            # rotate by 90 degrees
            dual_edge = anp.array([dual_edge[1], -dual_edge[0]])
            dual_edge = dual_edge / np.linalg.norm(dual_edge)
            primal_edge = [face_key_dict[fc._fid] for fc in [he.face, he.twin.face]] # 0= he, 1= twin
            e_dual.append(dual_edge)
            e_lst_primal.append(primal_edge)
    e_dual = anp.array(e_dual)
    e_lst_primal = anp.array(e_lst_primal)
    
    # breaking translational invariance.
    center = anp.mean([v.coords for v in self.vertices.values()], axis=0)
    
    def get_E(x0):
        x, y = (x0[:n_faces], x0[n_faces:])
        pts = anp.stack([x, y], axis=-1)
        # face-based shape energy
        cells = anp.stack([pts[i] for i in cell_list.T], axis=0)
        edges = cells - anp.roll(cells, 1, axis=0)
        lengths = anp.linalg.norm((edges.T + valence_mask).T, axis=-1) + 10*epsilon_l
        # stupid hack to avoid 0-division error due to padding in the jacobian
        units = (edges.T/lengths.T).T
        tensors = anp.einsum('efi,efj->fij', edges, units) 
        delta = tensors - rest_shapes
        E_shape = (mod_shear*4*anp.mean(delta**2)
                   + mod_bulk*anp.mean((delta[:,0,0]+delta[:,1,1])**2))
        # regularize with the vertex model energy
        if reg_bulk > 0:
            E_vertex = reg_bulk*anp.mean((polygon_area(cells)-A0)**2)
        else:
            E_vertex = 0
        # angle penalty
        pts = anp.stack([x, y], axis=-1)
        e_primal = pts[e_lst_primal[:,1]] - pts[e_lst_primal[:,0]] # he.twin.face-he.face
        lengths = anp.linalg.norm(e_primal, axis=-1) 
        # + epsilon to avoid 0-division error and make penalty smooth as length passes through 0
        # makes energy barrier so need epsilon small!
        penalty = (1-anp.einsum('ei,ei->e', e_primal, e_dual)/(lengths+epsilon_l))
        E_angle = angle_penalty * anp.mean(penalty) 
        # break translation symmetry
        E_trans = 1/2*((anp.mean(x)-center[0])**2+(anp.mean(y)-center[0]))**2
        # boundary energy
        E_bdry = 0
        for bdry_component, fct in zip(bdry_ids, bdry_penalty_fcts):
            for v in bdry_component:
                centroid = pts[v,:].mean(axis=0)
                E_bdry = E_bdry+bdry_penalty*fct(centroid)
        return E_angle + E_shape + E_vertex + E_bdry #+ E_trans
    
    return get_E, agrad(get_E)
