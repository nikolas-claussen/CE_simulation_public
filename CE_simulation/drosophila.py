# AUTOGENERATED! DO NOT EDIT! File to edit: ../04_drosophila_simulation.ipynb.

# %% auto 0
__all__ = ['fridtjof_colors', 'fridtjof_colors_new', 'blue_gray_red_cmap', 'is_notebook', 'save_self', 'create_rect_initial',
           'plot_mesh', 'get_color', 'get_normalized_bbox', 'make_segments', 'colorline', 'get_p_over_sqrt_A']

# %% ../04_drosophila_simulation.ipynb 3
import CE_simulation.mesh as msh
import CE_simulation.tension as tns
import CE_simulation.delaunay as dln
import CE_simulation.isogonal as iso

# %% ../04_drosophila_simulation.ipynb 4
import os
import sys

import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.collections import LineCollection

from scipy import optimize, ndimage

from tqdm.notebook import tqdm

from copy import deepcopy
import pickle

# %% ../04_drosophila_simulation.ipynb 5
from typing import Union, Dict, List, Tuple, Iterable, Callable, Any
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../04_drosophila_simulation.ipynb 6
import jax.numpy as jnp
from jax import grad as jgrad
from jax import jit
from jax.tree_util import Partial

from jax.config import config
config.update("jax_enable_x64", True) # 32 bit leads the optimizer to complain about precision loss
config.update("jax_debug_nans", False) # useful for debugging, but makes code slower!

# %% ../04_drosophila_simulation.ipynb 7
import ipywidgets as widgets
import functools
from matplotlib import animation, rc

# %% ../04_drosophila_simulation.ipynb 11
import time as time_module # so you don't accidentally overwrite the name 'time' with a variable
import shutil
import ipynbname
import inspect


def is_notebook() -> bool:
    """
    Test if code is being executed in a jupyter notebook or not.
    
    Source: stackoverflow.com/questions/15411967/how-can-i-check-if-code-is-executed-in-the-ipython-notebook
    """
    try:
        shell = get_ipython().__class__.__name__
        if shell == 'ZMQInteractiveShell':
            return True   # Jupyter notebook or qtconsole
        elif shell == 'TerminalInteractiveShell':
            return False  # Terminal running IPython
        else:
            return False  # Other type (?)
    except NameError:
        return False      # Probably standard Python interpreter

def save_self(save_dir, fname=None):
    """
    Save a copy of current python file to a directory, with a time stamp.

    If fname is None, automatically gets the filename of the current script/jupyter notebook.
    """
    if is_notebook() and (fname is None):
        fname = ipynbname.name() + ".ipynb"
    elif not is_notebook() and (fname is None):
        fname = inspect.stack()[1][1].split("/")[-1]
    nbname = os.getcwd()+'/'+fname
    copied_script_name = time_module.strftime("%Y-%m-%d_%H%M") + '_' + os.path.basename(nbname)
    print(f"saving as {copied_script_name}")
    shutil.copy(nbname, save_dir + os.sep + copied_script_name)

# %% ../04_drosophila_simulation.ipynb 14
## colors for cell rows -  from Fridtjof

fridtjof_colors = np.array([[0.34398, 0.49112, 0.89936],
                            [0.97, 0.606, 0.081],
                            [0.91, 0.318, 0.243],
                            [0.448, 0.69232, 0.1538],
                            [0.62168, 0.2798, 0.6914],
                            [0.09096, 0.6296, 0.85532],
                            [0.46056, 0.40064, 0.81392],
                            [0.94, 0.462, 0.162],
                            [0., 0.7, 0.7],
                            [0.827051, 0.418034, 0.0243459],
                            [0.5511749434976025, 0.32014794962639853, 0.8720626412559938],
                            [0.72694101250947, 0.7196601125010522, 0.],
                            [0.8680706456216862, 0.2563858708756628, 0.30321559063052295],
                            [0.2418693812442152, 0.5065044950046278, 0.9902432574930582],
                            [0.9573908706237908, 0.5369543531189542, 0.11504464931576472]])

fridtjof_colors_new = ["#e8513eff", "#e6e6e6ff",
                       "#f79b15ff", "#e6e6e6ff",
                       "#72b127ff", "#e6e6e6ff",
                       "#17a1daff", "#e6e6e6ff",
                       "#9f47b0ff", "#e6e6e6ff"]
fridtjof_colors_new = np.array([mpl.colors.to_rgb(x) for x in fridtjof_colors_new])

# %% ../04_drosophila_simulation.ipynb 15
def create_rect_initial(nx, ny, noise=0, initial_strain=0, isogonal=0, orientation='orthogonal',
                        boundaries=None, w_passive=0, w_passive_lr=0, w_bdry=.4, bdry_x=None, bdry_y=None,
                        random_seed=0):
    """
    Create initial condition for germ band simulations.
    
    Creates a CellHalfEdgeMesh from a rectangulat patch of triangular lattice, creates boundary conditions,
    selects active and passive triangles, creates a dictionary with the initial rows of active cells,
    and sets edge rest lengths and cell rest shapes.
    
    Random seed for noise can be specified for reproducible results.
    
    Parameters
    ----------
    nx, ny: int
        Width and height of rectangular patch
    noise: float
        Standard deviation of the noise added to the initial vertex positions
    initial_strain: float
        Initial y-axis strain applied to tension triangulation. Applies transform matrix
        diag(1/(1+s), 1+s)
    isogonal : float
        isogonal mode, incorporated into reference shape tensors. 0 = isotropic, >0 y-axis elongated
    orientation: 'orthogonal' or 'parallel'
        Orientation of hexagonal lattice direction w.r.t. y-axis.
    boundaries: list of 'top', 'bottom', 'left', 'right'
        On which sides to add slip walls.
    w_passive: float
        Width of passive region on the top and bottom
    w_passive_lr: float
        Width of passive region on the left and right
    bdry_x, bdry_y: float
        Location of the the left/right and top/bottom slip walls. If None, set to initial mesh positions
    random_seed: int
        Numpy random number generator seed.
        
    """
    np.random.seed(random_seed)
    # create the mesh
    if orientation == 'parallel':
        nx, ny = (ny, nx)
    mesh_initial = iso.CellHalfEdgeMesh(dln.create_rect_mesh(ny, nx, noise=noise,
                                                             straight_bdry=False))
    if orientation == 'orthogonal':
        mesh_initial.transform_vertices(dln.rot_mat(np.pi/2))
    center = np.mean([v.coords for v in mesh_initial.vertices.values()], axis=0)
    mesh_initial.transform_vertices(lambda x: x-center)
    mesh_initial.set_voronoi()
    
    mesh_initial.transform_vertices(dln.shear_mat(1+initial_strain))
    mesh_initial.set_rest_lengths()
    
    # create the boundary conditions
    boundaries = [] if boundaries is None else boundaries
    bdry_list = []
    max_x_cells = np.max([v.get_centroid()[0] for v in mesh_initial.vertices.values() if not v.is_bdry()])
    max_y_cells = np.max([v.get_centroid()[1] for v in mesh_initial.vertices.values() if not v.is_bdry()])

    bdry_x = np.ceil(max_x_cells) if bdry_x is None else bdry_x
    bdry_y = np.ceil(max_y_cells) if bdry_y is None else bdry_y
    
    if 'top' in boundaries:
        top_ids = []
        for v in mesh_initial.vertices.values():
            if (v.get_centroid()[1] > (max_y_cells-w_bdry)) and (not v.is_bdry()):
                top_ids.append(v._vid)
        def top_penalty(x):
            return (x[1]-bdry_y)**2
        top_penalty = Partial(jit(top_penalty))
        bdry_list.append([top_penalty, top_ids])

    if 'bottom' in boundaries:
        bottom_ids = []
        for v in mesh_initial.vertices.values():
            if (v.get_centroid()[1] < -(max_y_cells-w_bdry)) and (not v.is_bdry()):
                bottom_ids.append(v._vid)
        def bottom_penalty(x):
            return (x[1]+bdry_y)**2
        bottom_penalty = Partial(jit(bottom_penalty))
        bdry_list.append([bottom_penalty, bottom_ids])
        
    if 'left' in boundaries:
        left_ids = []
        for v in mesh_initial.vertices.values():
            if (v.get_centroid()[0] < -(max_x_cells-w_bdry)) and (not v.is_bdry()):
                left_ids.append(v._vid)
        def left_penalty(x):
            return (x[0]+bdry_x)**2
        left_penalty = Partial(jit(left_penalty))
        bdry_list.append([left_penalty, left_ids])

    if 'right' in boundaries:
        right_ids = []
        for v in mesh_initial.vertices.values():
            if (v.get_centroid()[0] > (max_x_cells-w_bdry)) and (not v.is_bdry()):
                right_ids.append(v._vid)
        def right_penalty(x):
            return (x[0]-bdry_x)**2
        right_penalty = Partial(jit(right_penalty))
        bdry_list.append([right_penalty, right_ids])    
    mesh_initial.bdry_list = bdry_list
        
    # set the active and passive triangles
    passive_faces = []
    max_y_faces = np.max([val.primal_coords[1] for val in mesh_initial.faces.values()])
    max_x_faces = np.max([val.primal_coords[0] for val in mesh_initial.faces.values()])

    for fc in mesh_initial.faces.values():
        if (fc.is_bdry()
            or (np.abs(fc.primal_coords[1]) > (max_y_faces-w_passive))
            or (np.abs(fc.primal_coords[0]) > (max_x_faces-w_passive_lr))):
            passive_faces.append(fc._fid)
            
    passive_faces = sorted(passive_faces)
    passive_edges = list(msh.flatten([[he._heid for he in mesh_initial.faces[fc].hes] for fc in passive_faces]))
    passive_cells = [v._vid for v in mesh_initial.vertices.values()
                     if not v.is_bdry() and any([fc._fid in passive_faces for fc in v.faces])]

    # create dict of initial row ids
    if orientation == 'parallel':
        initial_row_dict = {key: np.round((2/np.sqrt(3))*val.get_centroid()[1]+.5, decimals=0)
                            for key, val in mesh_initial.vertices.items()
                            if (not key in passive_cells) and (not val.is_bdry())}
    elif orientation == 'orthogonal':
        initial_row_dict = {key: np.round(val.get_centroid()[1], decimals=0)
                            for key, val in mesh_initial.vertices.items()
                            if (not key in passive_cells) and (not val.is_bdry())}
    min_val = min(initial_row_dict.values())
    initial_row_dict = {key: int(val-min_val) for key, val in initial_row_dict.items()}
    
    # set isogonal mode for active cells.
    for v in mesh_initial.vertices.values():
        if v._vid in passive_cells:
            v.rest_shape = np.sqrt(3) * np.array([[1, 0],[0, 1]])
        else:
            v.rest_shape = np.sqrt(3) * np.array([[1-isogonal, 0],[0, 1+isogonal]])

    property_dict = {'initial_row_dict': initial_row_dict, 'passive_faces': passive_faces,
                     'passive_edges': passive_edges, 'passive_cells': passive_cells,
                     'bdry_x': bdry_x, 'bdry_y': bdry_y}
    
    return mesh_initial, property_dict

# %% ../04_drosophila_simulation.ipynb 37
def plot_mesh(i, xlim, ylim, mesh_series, flipped_series=None,
              edge_colors=None, cell_colors=None, slipwall_y=None, plot_cell=True, plot_tri=False):
    """
    Plot time series of meshes (simulation results).
    
    This function is used primarily for interactive slider plots, and to create movies.
    Usage example, using widget.fixed to set the args you do not want to tune interactively:
    
    fig = plt.figure(figsize=(6, 6))
    widgets.interact(plot_mesh, i=(0, len(meshes)-1, 1), xlim=(bdry_x, 2*bdry_x),
                 ylim=widgets.fixed(bdry_y+.5), edge_colors=None, cell_colors=None,
                 mesh_series=widgets.fixed(meshes), flipped_series=widgets.fixed(last_flipped_edges));
    
    Parameters
    ----------
    i: int
        Time point to plot
    xlim, ylim: float
        x- and y- limits of the axes, symmetric about 0.
    mesh_series, flipped_series: list
        Time series of meshes and T1 events, as given by simulation loop
    edge_colors, cell_colors: dict
        color dict, see mesh.cell_plot
    slipwall_y: float or None
        If float, plot slip walls at top/bottom at this position. If None, don't plot anything. 
    plot_cell, plot_tri: bool
        plot cells and/or triangulation
    """
    
    plt.cla()
    if slipwall_y is not None:
        plt.hlines((slipwall_y, -slipwall_y), (-xlim, -xlim), (xlim, xlim), color="k")
    plt.xlim([-xlim, xlim])
    plt.ylim([-ylim, ylim])
    plt.gca().set_aspect("equal", adjustable="box")
    if plot_cell:
        mesh_series[i].cellplot(edge_colors=edge_colors,
                                cell_colors=cell_colors)
    #meshes[i].labelplot(halfedge_labels=True, vertex_labels=True, face_labels=False)
    if plot_tri:
        mesh_series[i].triplot()
    if flipped_series:
        for x in flipped_series[i+1]:
            he = mesh_series[i].hes[x]
            if plot_cell:
                line = np.stack([he.face.primal_coords, he.twin.face.primal_coords])
                plt.plot(*line.T, c="r", lw=4)
            if plot_tri:
                line = np.stack([he.vertices[0].coords, he.vertices[1].coords])
                plt.plot(*line.T, c="tab:purple", lw=5)

# %% ../04_drosophila_simulation.ipynb 48
from matplotlib.colors import LinearSegmentedColormap

# this color map is better than matplotlib's diverging color maps because it doesn't pass through
# white, so you can still see it on a white background
blue_gray_red_cmap =  LinearSegmentedColormap.from_list('my_gradient', (
    # Edit this gradient at https://eltos.github.io/gradient/#0032F5-0032F5-7A7A7A-F1030F-F10410
    (0.000, (0.000, 0.196, 0.961)),
    (0.250, (0.000, 0.196, 0.961)),
    (0.500, (0.478, 0.478, 0.478)),
    (0.750, (0.945, 0.012, 0.059)),
    (1.000, (0.945, 0.016, 0.063))))

# normalization function
def get_color(x, vmin=.4, vmax=1.6):
    return np.array(bgr((np.clip(x, vmin, vmax)-vmin)/(vmax-vmin)))


# %% ../04_drosophila_simulation.ipynb 59
def get_normalized_bbox(meshes, sigma=3, log=True):
    centroids = np.stack([[v.get_centroid() for key, v in mesh.vertices.items()
                       if not v.is_bdry()] for mesh in meshes[1:]])

    delta = np.quantile(centroids, axis=1, q=.9)-np.quantile(centroids, axis=1, q=.1,)
    delta_smooth = ndimage.gaussian_filter1d(delta, axis=0, sigma=sigma)[sigma:-sigma]
    delta_smooth /= delta_smooth[0]
    if log:
        delta_log = np.log(delta_smooth)
        return delta_log
    return delta_smooth

# %% ../04_drosophila_simulation.ipynb 64
def make_segments(x, y):
    """
    Create list of line segments from x and y coordinates, in the correct format
    for LineCollection: an array of the form numlines x (points per line) x 2 (x
    and y) array
    """

    points = np.array([x, y]).T.reshape(-1, 1, 2)
    segments = np.concatenate([points[:-1], points[1:]], axis=1)
    return segments

def colorline(x, y, z=None, cmap='cool', norm=plt.Normalize(0.0, 1.0),
              linewidth=3, alpha=1.0, ax=None):
    """
    http://nbviewer.ipython.org/github/dpsanders/matplotlib-examples/blob/master/colorline.ipynb
    http://matplotlib.org/examples/pylab_examples/multicolored_line.html
    Plot a colored line with coordinates x and y
    Optionally specify colors in the array z
    Optionally specify a colormap, a norm function and a line width
    """

    # Default colors equally spaced on [0,1]:
    is_3d = ~(z is None)
    if is_3d:
        z = np.linspace(0.0, 1.0, len(x))

    # Special case if a single number:
    # to check for numerical input -- this is a hack
    if not hasattr(z, "__iter__"):
        z = np.array([z])

    z = np.asarray(z)

    segments = make_segments(x, y)
    lc = LineCollection(segments, array=z, cmap=cmap, norm=norm,
                        linewidth=linewidth, alpha=alpha)

    if ax is None:
        ax = plt.gca()
    ax.add_collection(lc)
        
    return lc

# %% ../04_drosophila_simulation.ipynb 78
def get_p_over_sqrt_A(v: msh.Vertex) -> float:
    """Compute perimeter/sqrt(area) of cell. Returns None for boundary cells."""
    if v.is_bdry():
        return None
    return tns.polygon_perimeter(v.primal_coords) / np.sqrt(tns.polygon_area(v.primal_coords))
