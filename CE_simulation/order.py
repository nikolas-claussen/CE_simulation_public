# AUTOGENERATED! DO NOT EDIT! File to edit: ../17_order_from_disorder.ipynb.

# %% auto 0
__all__ = ['homeostatic_dt_act_pass']

# %% ../17_order_from_disorder.ipynb 3
import CE_simulation.mesh as msh
import CE_simulation.tension as tns
import CE_simulation.delaunay as dln
import CE_simulation.isogonal as iso
import CE_simulation.drosophila as drs
import CE_simulation.disorder as dis
import CE_simulation.hessian as hes
import CE_simulation.ecmc as ecm
import CE_simulation.phase_analysis as ana

# %% ../17_order_from_disorder.ipynb 4
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from tqdm.notebook import tqdm

from scipy import spatial, ndimage

from collections import Counter
import itertools

from copy import deepcopy
import os
import pickle

# %% ../17_order_from_disorder.ipynb 5
from joblib import Parallel, delayed
import gc

# %% ../17_order_from_disorder.ipynb 6
import jax
import jax.numpy as jnp
from jax import jit

from jax.config import config
config.update("jax_enable_x64", True)
config.update("jax_debug_nans", False)

# %% ../17_order_from_disorder.ipynb 7
from typing import Sequence, Union, Dict, List, Tuple, Iterable, Callable, Any
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../17_order_from_disorder.ipynb 12
def homeostatic_dt_act_pass(Ts: NDArray[Shape["3"], Float], Tps: NDArray[Shape["3"], Float],
                            T0=1, k=1, is_active=True, **varargs):
    """
    Time derivative of tensions under saturating positive feedback model, including passive tension.
    
    Parameters
    ----------
    Ts : (3,) array
        active tensions
    Tps : (3,) array
        passive tensions
    k : float
        passive tension relaxation rate
    is_active : bool
        Whether the given triangle is active. Otherwise, relax to 1.
        
    Returns
    -------
    dT_dt : (3,) array
        time derivative of active tension
    dTp_dt : (3,) array
        time derivative of passive tension

    """
    if is_active:
        #dT_dt = -k*(Ts-T0) - k*Tps
        dT_dt = -k*(Ts-T0)**2 - k*Tps

    else:
        dT_dt = -k*(Ts-1)
    dTp_dt = -k*Tps
    dT_dt -= dT_dt.mean()
    return dT_dt, dTp_dt

# might need to add cutoff to ensure tensions remain positive

# %% ../17_order_from_disorder.ipynb 14
@patch
def euler_maruyama_step(self: tns.TensionHalfEdgeMesh, dt, rhs_tension, sigma=0,
                        params=None, rhs_rest_shape: Union[None, callable]=None) -> None:
    """
    Euler-Maruyama step intrinsic edge length and reference shapes. 
    
    In contrast to Euler step, this includes a normal i.i.d. noise term (independent for each half edge).
    Passive tensions do not fluctuate. Tensions cannot become negative (hard constraint...).
    Iterates over mesh triangles and cells, updating the intrinsic properties (active and passive tensions,
    reference shapes) using the provided ODE RHS functions.
    
    Implements spatial patterning of the tension evolution equations via the params keyword.
    
    Parameters
    ----------
    dt : float
        Time step
    rhs_tension : callable
        Function which takes arguments (T_active, T_passive) and returns their time derivatives
    sigma : float
        Noise standard deviation
    params : dict or callable
        Parameters for the rhs_tension function. Can be a function from face ids -> parameter dict,
        allowing different triangles to evolve differently.
    rhs_rest_shape : callable
        Function which takes a vertex as argument and returns the time derivative of the rest shape
        (e.g. viscous relaxation). If None, the function returns 0.
    
    """
    # Euler step edges
    for fc in self.faces.values():
        # collect edges
        Ts, Tps = (np.array([he.rest for he in fc.hes]), np.array([he.passive for he in fc.hes]))
        if isinstance(params, dict):
            dT_dt, dTp_dt = rhs_tension(Ts, Tps, **params)
        elif callable(params):
            dT_dt, dTp_dt = rhs_tension(Ts, Tps, **params(fc._fid))
        Ts += dt*dT_dt
        Tps += dt*dTp_dt
        # noise
        if callable(sigma):
            if isinstance(params, dict):
                noise = sigma(Ts, Tps, **params)*np.random.normal(loc=0, scale=1, size=(3,))
            elif callable(params):
                noise = sigma(Ts, Tps, **params(fc._fid))*np.random.normal(loc=0, scale=1, size=(3,))
        else:
            noise = sigma*np.random.normal(loc=0, scale=1, size=(3,))
        Ts = Ts + np.sqrt(dt)*noise
        Ts = np.clip(Ts, 0, np.inf)
        
        for T, Tp, he in zip(Ts, Tps, fc.hes):
            he.rest = T
            he.passive = Tp
    # Euler step cells, if desired
    if rhs_rest_shape is not None:
        for v in self.vertices.values():
            v.rest_shape += dt*rhs_rest_shape(v)
