# AUTOGENERATED! DO NOT EDIT! File to edit: ../11_saturating_feedback.ipynb.

# %% auto 0
__all__ = ['excitable_dt', 'excitable_dt_act_pass', 'saturating_dt', 'saturating_dt_act_pass']

# %% ../11_saturating_feedback.ipynb 3
import CE_simulation.mesh as msh
import CE_simulation.tension as tns
import CE_simulation.delaunay as dln
import CE_simulation.isogonal as iso
import CE_simulation.drosophila as drs
import CE_simulation.disorder as dis
import CE_simulation.hessian as hes
import CE_simulation.ecmc as ecm
import CE_simulation.phase_analysis as ana

# %% ../11_saturating_feedback.ipynb 4
import numpy as np
import matplotlib.pyplot as plt
from tqdm.notebook import tqdm

from scipy import spatial, ndimage

from collections import Counter
import itertools

from copy import deepcopy
import os
import pickle

# %% ../11_saturating_feedback.ipynb 5
from joblib import Parallel, delayed
import gc

# %% ../11_saturating_feedback.ipynb 6
import jax.numpy as jnp
from jax import grad as jgrad
from jax import jit
from jax.nn import relu

from jax.config import config
config.update("jax_enable_x64", True)
config.update("jax_debug_nans", False)

# %% ../11_saturating_feedback.ipynb 7
from typing import Sequence, Union, Dict, List, Tuple, Iterable, Callable, Any
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../11_saturating_feedback.ipynb 26
def excitable_dt(Ts, m=4, k_cutoff=0):
    dT_dt = Ts**m - k_cutoff*Ts**(m+1)
    dT_dt -= dT_dt.mean()
    return dT_dt

# %% ../11_saturating_feedback.ipynb 27
def excitable_dt_act_pass(Ts: NDArray[Shape["3"], Float], Tps: NDArray[Shape["3"], Float],
                          k=1, m=2, k_cutoff=0, is_active=True, subtract_passive=True,
                         ) -> Tuple[NDArray[Shape["3"],Float],NDArray[Shape["3"],Float]]:
    """
    Time derivative of tensions under excitable tension model, including passive tension.
    
    Perimeter version -- keeps triangle perimeter fixed. Perimeter of the passive tension may vary of course.
    
    Implements the following equations:
        d_dt T = T^m
        d_dt T_passive = -k*T_passive
    
    with the following additions:
        - a -k_cutoff*T^(m+1) term which cuts of excitable feedback at large tensions for numerical stability
        - projection of the d_dt T - vector on triangle-perimter-preserving edge length changes
    
    For m==1 (no excitable tension feedback), we implement a special case:
        d_dt T = -k*(T-1)
    i.e. tensions relax back to equilateral. This will be useful later to model completely
    passive edges with no excitable dynamics.
    
    Parameters
    ----------
    Ts : (3,) array
        active tensions
    Tps : (3,) array
        passive tensions
    k : float
        passive tension relaxation rate
    m : float
        excitable tension exponent
    k_cutoff : 
        cutoff for excitable tension. 0 = no cutoff.
        
    Returns
    -------
    dT_dt : (3,) array
        time derivative of active tension
    dTp_dt : (3,) array
        time derivative of passive tension


    """
    if is_active:
        if subtract_passive:
            dT_dt = (Ts-Tps)**m - k_cutoff*(Ts-Tps)**(m+1) - k*Tps
        else:
            dT_dt = Ts**m - k_cutoff*Ts**(m+1) - k*Tps
        dTp_dt = -k*Tps
        dT_dt -= dT_dt.mean()
    else:
        dT_dt = -k*(Ts-Tps)
        dTp_dt = np.zeros(3)
        dT_dt -= dT_dt.mean()
    return dT_dt, dTp_dt

# %% ../11_saturating_feedback.ipynb 28
# define saturating feedback function

def saturating_dt(Ts, T_minus=0, T_c=1, T_plus=2):
    dT_dt = -(Ts-T_minus)*(Ts-T_c)*(Ts-T_plus)
    dT_dt -= dT_dt.mean()
    return dT_dt

# %% ../11_saturating_feedback.ipynb 29
# define saturating feedback function

def saturating_dt_act_pass(Ts: NDArray[Shape["3"], Float], Tps: NDArray[Shape["3"], Float],
                           T_minus=0, T_c=1, T_plus=2, k=1, is_active=True, subtract_passive=True,
                           ) -> Tuple[NDArray[Shape["3"],Float],NDArray[Shape["3"],Float]]:
    """
    Time derivative of tensions under saturating positive feedback model, including passive tension.
    
    Parameters
    ----------
    Ts : (3,) array
        active tensions
    Tps : (3,) array
        passive tensions
    T_minus, T_c, T_plus: float
        Fixed points of tension feedback
    k : float
        passive tension relaxation rate
    is_active : bool
        Whether the given triangle is active. Otherwise, relax to 1.
        
    Returns
    -------
    dT_dt : (3,) array
        time derivative of active tension
    dTp_dt : (3,) array
        time derivative of passive tension

    """
    if is_active:
        if subtract_passive:
            dT_dt = -((Ts-Tps)-T_minus)*((Ts-Tps)-T_c)*((Ts-Tps)-T_plus) - k*Tps
        else:
            dT_dt = -(Ts-T_minus)*(Ts-T_c)*(Ts-T_plus) - k*Tps
        dTp_dt = -k*Tps
        dT_dt -= dT_dt.mean()
    else:
        dT_dt = -k*(Ts-1)
        dTp_dt = np.zeros(3)
        dT_dt -= dT_dt.mean()
    return dT_dt, dTp_dt
