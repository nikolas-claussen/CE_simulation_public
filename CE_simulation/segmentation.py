# AUTOGENERATED! DO NOT EDIT! File to edit: ../07_from_segmentation.ipynb.

# %% auto 0
__all__ = ['for_imshow', 'prepare_input', 'get_com_dict']

# %% ../07_from_segmentation.ipynb 2
import CE_simulation.mesh as msh
import CE_simulation.tension as tns
import CE_simulation.delaunay as dln
import CE_simulation.isogonal as iso
import CE_simulation.drosophila as drs

# %% ../07_from_segmentation.ipynb 3
import os
import sys

import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

from scipy import optimize, ndimage, sparse

from tqdm.notebook import tqdm

from copy import deepcopy
import pickle

# %% ../07_from_segmentation.ipynb 4
from typing import Union, Dict, List, Tuple, Iterable, Callable, Any
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../07_from_segmentation.ipynb 5
import jax.numpy as jnp
from jax import jit
import jax
from jax.tree_util import Partial

from jax.config import config
config.update("jax_enable_x64", True) # 32 bit leads the optimizer to complain about precision loss
config.update("jax_debug_nans", False) # useful for debugging, but makes code slower!

# %% ../07_from_segmentation.ipynb 6
import ipywidgets as widgets
import functools
from matplotlib import animation, rc

# %% ../07_from_segmentation.ipynb 7
from skimage import measure, segmentation, future
import networkx as nx

# %% ../07_from_segmentation.ipynb 16
def for_imshow(labeled: NDArray[Shape["*,*"], Int], colors: NDArray[Shape["*,3"], Float]=drs.fridtjof_colors
              ) -> NDArray[Shape["*,*,3"], Float]:
    """Create colored array from labeled image using array of RBG colors, with black boundaries."""
    bdry = segmentation.find_boundaries(labeled, mode='outer')
    rgb = colors[labeled % colors.shape[0]]
    rgb = (rgb.transpose((2,0,1)) * (bdry == 0)).transpose((1,2,0))
    return rgb

# %% ../07_from_segmentation.ipynb 20
def _add_edge_filter(values, graph_dict):
    """Create edge in `graph_dict` between central element of `values` and the rest.
    Add an edge between the middle element in `values` and
    all other elements of `values` into `graph`.  ``values[len(values) // 2]``
    is expected to be the central value of the footprint used.
    Parameters
    ----------
    values : array
        The array to process.
    graph_dict : dict
        The graph to add edges in.
    Returns
    -------
    0 : float
        Always returns 0. The return value is required so that `generic_filter`
        can put it in the output array, but it is ignored by this filter.
    """
    values = values.astype(int)
    center = values[len(values) // 2]
    for value in values:
        if value != center:
            graph_dict[center].add(value)
    return 0.

# %% ../07_from_segmentation.ipynb 21
def _4fold_filter(values, graph_dict):
    """
    Create edges in `graph_dict` for 4-fold vertices which meet in the square configuration.
    
    To avoid 
    
    Parameters
    ----------
    values : array
        The array to process. Should to be of shape 4 from a 2x2 strelm
    graph_dict : dict
        The graph to add edges in.
    Returns
    -------
    0 : float
        Always returns 0. The return value is required so that `generic_filter`
        can put it in the output array, but it is ignored by this filter.
    """
    values = values.astype(int)
    if np.unique(values).size == values.size:
        graph_dict[values[0]].add(values[3])
        graph_dict[values[3]].add(values[0])
    return 0.

# %% ../07_from_segmentation.ipynb 31
def prepare_input(segmentation):
    
    pass

# %% ../07_from_segmentation.ipynb 39
def get_com_dict(labeled: NDArray[Shape["*,*"], Int]) -> Dict[int, NDArray[Shape["2"], Float]]: 
    """Get the centroids of regions in a labeled array"""
    return {key: np.array(ndimage.center_of_mass(labeled==key)) for key in np.unique(labeled)}
        
