# AUTOGENERATED! DO NOT EDIT! File to edit: ../03_real_shape_optimization.ipynb.

# %% auto 0
__all__ = ['polygon_area', 'polygon_perimeter', 'get_vertex_energy', 'rotate_about_center']

# %% ../03_real_shape_optimization.ipynb 4
from .triangle import *
from .tension import *
from .delaunay import *

# %% ../03_real_shape_optimization.ipynb 5
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl

from numpy import sin, cos, tan, pi, sqrt, arccos, arctan, arctan2
from numpy.linalg import norm

from scipy.integrate import solve_ivp
from scipy import ndimage
from scipy import spatial
from scipy import optimize

from tqdm.notebook import tqdm

from math import floor, ceil

import sys

from copy import deepcopy

from collections import Counter

# %% ../03_real_shape_optimization.ipynb 6
from dataclasses import dataclass
from typing import Union, Dict, List, Tuple, Iterable, Callable
from nptyping import NDArray, Int, Float, Shape

from fastcore.foundation import patch

# %% ../03_real_shape_optimization.ipynb 7
import autograd.numpy as anp  # Thinly-wrapped numpy
from autograd import grad as agrad

from scipy.sparse import csc_matrix

# %% ../03_real_shape_optimization.ipynb 10
import ipywidgets as widgets

# %% ../03_real_shape_optimization.ipynb 17
from matplotlib import animation, rc
rc('animation', html='html5')

# %% ../03_real_shape_optimization.ipynb 30
def polygon_area(pts):
    """area of polygon assuming no self-intersection. pts.shape (n_vertices, 2)"""
    return anp.sum(pts[:,0]*anp.roll(pts[:,1], 1, axis=0) - anp.roll(pts[:,0], 1, axis=0)*pts[:,1])/2

def polygon_perimeter(pts):
    """perimeter of polygon assuming no self-intersection. pts.shape (n_vertices, 2)"""
    return anp.sum(anp.linalg.norm(pts-anp.roll(pts, 1, axis=0), axis=1))

def get_vertex_energy(pts, A0=1, P0=1, mod_shear=0, mod_bulk=1):
    """Get vertex style energy"""
    return mod_bulk*(polygon_area(pts)-A0)**2 + mod_shear*(polygon_perimeter(pts)-P0)**2

# %% ../03_real_shape_optimization.ipynb 32
# new plotting functions
@patch
def cellplot(self: HalfEdgeMesh, alpha=1):
    """Plot based on primal positions. Might be slow because loops over faces"""
    for fc in self.faces.values():
        for he in fc.hes:
            nghb = he.twin.face
            if nghb is not None:
                line = np.stack([fc.dual_coords, nghb.dual_coords])
                plt.plot(*line.T, c="k", alpha=alpha)

@patch
def labelplot(self: HalfEdgeMesh, vertex_labels=True, face_labels=True,
                     halfedge_labels=False, cell_labels=False):
    """for debugging purposes, a fct to plot a trimesh with labels attached"""
    if face_labels:
        for fc in self.faces.values():
            centroid = np.mean([he.vertices[0].coords for he in fc.hes], axis=0)
            plt.text(*centroid, str(fc._fid), color="k")
    if vertex_labels:
        for v in self.vertices.values():
            plt.text(*(v.coords+np.array([0,.05])), str(v._vid),
                     color="tab:blue", ha="center")
    if cell_labels:
        for v in self.vertices.values():
            nghbs = v.get_face_neighbors()
            if not (None in nghbs):
                center = np.mean([fc.dual_coords for fc in nghbs], axis=0)
                plt.text(*(center), str(v._vid),
                         color="tab:blue", ha="center")
    if halfedge_labels:
        for he in self.hes.values():
            if he.duplicate:
                centroid = np.mean([v.coords for v in he.vertices], axis=0)
                plt.text(*centroid, str(he._heid), color="tab:orange")

# %% ../03_real_shape_optimization.ipynb 33
@patch
def get_face_neighbors(self: Vertex):
    """Get face neighbors of vertex"""
    neighbors = []
    start_he = self.incident[0]
    he = start_he
    returned = False
    while not returned:
        neighbors.append(he.face)
        he = he.nxt.twin
        returned = (he == start_he)
    return neighbors

@patch
def set_centroid(self: HalfEdgeMesh):
    """Set dual positions to triangle centroid"""
    for fc in self.faces.values():
        vecs = []
        returned = False
        start_he = fc.hes[0]
        he = start_he
        while not returned:
            vecs.append(he.vertices[0].coords)
            he = he.nxt
            returned = (he == start_he)
        fc.dual_coords = np.mean(vecs, axis=0)

@patch
def transform_dual_vertices(self: HalfEdgeMesh, trafo: Union[Callable, NDArray[Shape["2, 2"], Float]]):
    for fc in self.faces.values():
        if isinstance(trafo, Callable):
            fc.dual_coords = trafo(fc.dual_coords)
        else:
            fc.dual_coords = trafo.dot(fc.dual_coords)

# %% ../03_real_shape_optimization.ipynb 35
@patch
def dual_vertices_to_initial_cond(self: HalfEdgeMesh):
    """Format dual vertices for use in energy minimization."""
    face_keys = sorted(self.faces.keys())
    dual_vertex_vector = np.stack([self.faces[key].dual_coords for key in face_keys]).T
    return np.hstack([dual_vertex_vector[0], dual_vertex_vector[1]])
       
@patch
def initial_cond_to_dual_vertices(self: HalfEdgeMesh, x0):
    """Reverse of format dual vertices for use in energy minimization."""
    face_keys = sorted(self.faces.keys())
    x, y = (x0[:int(len(x0)/2)], x0[int(len(x0)/2):])
    dual_vertex_vector = np.stack([x, y], axis=1)
    return {key: val for key, val in zip(face_keys, dual_vertex_vector)}


# %% ../03_real_shape_optimization.ipynb 37
@patch
def get_angle_deviation(self: HalfEdgeMesh):
    """Angle between primal and dual edges. For diagnostics"""
    angle_deviation = {}

    for he in self.hes.values():
        if (he.face is not None) and (he.twin.face is not None):
            dual_edge = he.vertices[1].coords-he.vertices[0].coords
            primal_edge = he.face.dual_coords - he.twin.face.dual_coords
            dual_edge = dual_edge / np.linalg.norm(dual_edge)
            primal_edge = primal_edge / np.linalg.norm(primal_edge)        
            angle_deviation[he._heid] = np.dot(dual_edge, primal_edge)**2
    return angle_deviation

# %% ../03_real_shape_optimization.ipynb 42
@patch
def is_bdr(self: Face):
    """True if face touches bdr. Check all vertices. Does any have an incident edge with None face?"""
    verts = [he.vertices[1] for he in self.hes]
    return any([any([he.face is None for he in v.incident]) for v in verts])

# %% ../03_real_shape_optimization.ipynb 46
@patch
def get_primal_energy_fct_vertices(self: HalfEdgeMesh, mod_bulk=1, mod_shear=1e-3, angle_penalty=1e2,
                                   metric=False, oriented=False, rest_shape=None,
                                   regularization="per-cell", 
                                   reg_bulk=0, reg_shear=0, A0=sqrt(3)/2, P0=2*sqrt(3)):
    """Get function to compute primal energy from primal vertices."""
    if rest_shape is None:
        rest_shape = np.eye(2) if metric else 2*np.eye(2)

    # stuff for the shape tensor energy
    face_list = []
    rest_shapes = []
    
    face_key_dict = {key: ix for ix, key in enumerate(sorted(self.faces.keys()))}
    face_key_dict[None] = None
    reference_edges = []
    
    # we want to also check the orientation of each edge. compare to connectors of tri centroids
    for fc in self.faces.values():
        neighbors = [he.twin.face for he in fc.hes]
        if not (None in neighbors):
            face_list.append(anp.array([face_key_dict[x._fid] for x in neighbors]
                                       +[face_key_dict[fc._fid]]))
            reference_edges.append([x.dual_coords-fc.dual_coords for x in neighbors])
    face_list = anp.array(face_list).T
    n_faces = len(self.faces)
    reference_edges = anp.array(reference_edges).transpose((1,0,2))
    reference_edges = (reference_edges.T / np.linalg.norm(reference_edges, axis=-1).T).T

    # stuff for the vertex-energy-based regularization
    cell_list = []
    for v in self.vertices.values():    # iterate around vertex.
        neighbors = v.get_face_neighbors()
        if not (None in neighbors):
            cell_list.append(anp.array([face_key_dict[fc._fid] for fc in neighbors]))
    bdry_faces = anp.array([face_key_dict[fc] for fc in get_boundary_faces(self)])
    
    # stuff for the angle penalty
    e_dual = [] # dual vertices do not move during optimization, so collect the actual edges
    e_lst_primal = [] # for primal, collect the indices

    for he in self.hes.values():
        if (he.face is not None) and (he.twin.face is not None) and he.duplicate:
            dual_edge = he.vertices[1].coords-he.vertices[0].coords
            dual_edge = dual_edge / np.linalg.norm(dual_edge)
            primal_edge = [face_key_dict[fc._fid] for fc in [he.face, he.twin.face]]
            e_dual.append(dual_edge)
            e_lst_primal.append(primal_edge)
    e_dual = anp.array(e_dual)
    e_lst_primal = anp.array(e_lst_primal)    
    center = anp.mean([fc.dual_coords for fc in self.faces.values()], axis=0)
    
    def get_E(x0):
        x, y = (x0[:n_faces], x0[n_faces:])
        pts = anp.stack([x, y], axis=-1)
        
        # shape energy - can be either vertex style or shape tensor based
        E_shape = 0
        edges = anp.stack([pts[a]-pts[face_list[3]] for a in face_list[:3]])
        # get orientations and lengths of edges
        orientations = anp.sign(anp.einsum("efi,efi->ef", edges, reference_edges))
        lengths = anp.linalg.norm(edges, axis=-1)
        if metric and oriented:
            oriented_edges = (edges.T*orientations.T).T
        elif metric and (not oriented):
            oriented_edges = edges
        elif (not metric) and oriented:
            oriented_edges = (edges.T*orientations.T/lengths.T).T
        elif (not metric) and (not oriented):
            oriented_edges = (edges.T/lengths.T).T        
        tensors = 2*anp.einsum('efi,efj->fij', edges, oriented_edges) - rest_shape
        E_shape = (mod_shear*anp.sum(tensors**2)
                   + mod_bulk*anp.sum((tensors[:,0,0]+tensors[:,1,1])**2))
        
        # regularize with the vertex model energy
        E_vertex = 0
        if regularization == "per-cell":
            if reg_bulk > 0 or reg_shear > 0:
                for cll in cell_list:
                    poly = anp.stack([x[cll], y[cll]], axis=-1)
                    E_vertex = (E_vertex+reg_bulk*(polygon_area(poly)-A0)**2
                                + reg_shear*(polygon_perimeter(poly)-P0)**2)
        elif regularization == "total-area":
            poly = anp.stack([x[bdry_faces], y[bdry_faces]], axis=-1)
            area = polygon_area(poly)
            E_vertex = reg_bulk*(area-len(cell_list)*A0)**2
        # angle penalty
        e_primal = pts[e_lst_primal[:,1]] - pts[e_lst_primal[:,0]]
        e_primal = (e_primal.T/anp.linalg.norm(e_primal, axis=-1)).T
        E_angle = angle_penalty * anp.mean(anp.einsum('ei,ei->e', e_primal, e_dual)**2)
        # break translation symmetry
        E_trans = 1/2*((anp.mean(x)-center[0])**2+(anp.mean(y)-center[0]))**2
        
        return E_shape + E_angle + E_vertex #+ E_trans
    
    return get_E, agrad(get_E)

# %% ../03_real_shape_optimization.ipynb 53
@patch
def get_primal_edge_lens(self: HalfEdgeMesh):
    return {he._heid: np.linalg.norm(he.face.dual_coords-he.twin.face.dual_coords)
            for key, he in self.hes.items()
            if (he.face is not None) and (he.twin.face is not None) and he.duplicate} 
    
    return None

# %% ../03_real_shape_optimization.ipynb 56
# for re-setting primal vertex positions after intercalation
def rotate_about_center(x, angle=pi/2):
    """Rotate pts about center. x.shape = (n_pts, 2)"""
    center = np.mean(x, axis=0)
    return (x-center)@rot_mat(angle)+np.mean(x, axis=0)

# %% ../03_real_shape_optimization.ipynb 58
@patch
def flatten_triangulation(self: HalfEdgeMesh, tol=1e-3):
    """flatten triangulation"""
    get_E, grd = self.get_energy_fct()
    x0 = self.vertices_to_initial_cond()
    sol = optimize.minimize(get_E, x0, method="CG", jac=grd, tol=tol)
    if sol["status"] !=0:
        print("Triangulation optimization failed")
        print(sol["message"])
    new_coord_dict = self.initial_cond_to_vertices(sol["x"])
    for key, val in self.vertices.items():
        val.coords = new_coord_dict[key]
    self.set_rest_lengths()
